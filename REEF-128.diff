diff --git a/lang/java/reef-common/pom.xml b/lang/java/reef-common/pom.xml
index 6768a4b..c6efe04 100644
--- a/lang/java/reef-common/pom.xml
+++ b/lang/java/reef-common/pom.xml
@@ -58,7 +58,6 @@ under the License.
                                     <arg value="src/main/proto/reef_service_protos.proto"/>
                                     <arg value="src/main/proto/evaluator_runtime.proto"/>
                                     <arg value="src/main/proto/client_runtime.proto"/>
-                                    <arg value="src/main/proto/driver_runtime.proto"/>
                                     <arg value="src/main/proto/reef_protocol.proto"/>
                                 </exec>
                             </tasks>
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/JobSubmissionHelper.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/JobSubmissionHelper.java
index 6b89c09..63ddee7 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/JobSubmissionHelper.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/JobSubmissionHelper.java
@@ -19,8 +19,10 @@
 package org.apache.reef.runtime.common.client;
 
 import org.apache.reef.driver.parameters.*;
-import org.apache.reef.proto.ClientRuntimeProtocol;
-import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.runtime.common.client.api.JobSubmissionEventImpl;
+import org.apache.reef.runtime.common.files.FileResource;
+import org.apache.reef.runtime.common.files.FileResourceImpl;
+import org.apache.reef.runtime.common.files.FileType;
 import org.apache.reef.tang.Configuration;
 import org.apache.reef.tang.Injector;
 import org.apache.reef.tang.Tang;
@@ -71,10 +73,10 @@ final class JobSubmissionHelper {
    * @throws InjectionException
    * @throws IOException
    */
-  final ClientRuntimeProtocol.JobSubmissionProto.Builder getJobsubmissionProto(final Configuration driverConfiguration) throws InjectionException, IOException {
+  final JobSubmissionEventImpl.Builder getJobsubmissionProto(final Configuration driverConfiguration) throws InjectionException, IOException {
     final Injector injector = Tang.Factory.getTang().newInjector(driverConfiguration);
 
-    final ClientRuntimeProtocol.JobSubmissionProto.Builder jbuilder = ClientRuntimeProtocol.JobSubmissionProto.newBuilder()
+    final JobSubmissionEventImpl.Builder jbuilder = JobSubmissionEventImpl.newBuilder()
         .setIdentifier(returnOrGenerateDriverId(injector.getNamedInstance(DriverIdentifier.class)))
         .setDriverMemory(injector.getNamedInstance(DriverMemory.class))
         .setUserName(System.getProperty("user.name"))
@@ -83,22 +85,22 @@ final class JobSubmissionHelper {
 
     for (final String globalFileName : injector.getNamedInstance(JobGlobalFiles.class)) {
       LOG.log(Level.FINEST, "Adding global file: {0}", globalFileName);
-      jbuilder.addGlobalFile(getFileResourceProto(globalFileName, ReefServiceProtos.FileType.PLAIN));
+      jbuilder.addGlobalFile(getFileResourceProto(globalFileName, FileType.PLAIN));
     }
 
     for (final String globalLibraryName : injector.getNamedInstance(JobGlobalLibraries.class)) {
       LOG.log(Level.FINEST, "Adding global library: {0}", globalLibraryName);
-      jbuilder.addGlobalFile(getFileResourceProto(globalLibraryName, ReefServiceProtos.FileType.LIB));
+      jbuilder.addGlobalFile(getFileResourceProto(globalLibraryName, FileType.LIB));
     }
 
     for (final String localFileName : injector.getNamedInstance(DriverLocalFiles.class)) {
       LOG.log(Level.FINEST, "Adding local file: {0}", localFileName);
-      jbuilder.addLocalFile(getFileResourceProto(localFileName, ReefServiceProtos.FileType.PLAIN));
+      jbuilder.addLocalFile(getFileResourceProto(localFileName, FileType.PLAIN));
     }
 
     for (final String localLibraryName : injector.getNamedInstance(DriverLocalLibraries.class)) {
       LOG.log(Level.FINEST, "Adding local library: {0}", localLibraryName);
-      jbuilder.addLocalFile(getFileResourceProto(localLibraryName, ReefServiceProtos.FileType.LIB));
+      jbuilder.addLocalFile(getFileResourceProto(localLibraryName, FileType.LIB));
     }
 
     return jbuilder;
@@ -130,7 +132,7 @@ final class JobSubmissionHelper {
    * @return
    * @throws IOException
    */
-  private static ReefServiceProtos.FileResourceProto getFileResourceProto(final String fileName, final ReefServiceProtos.FileType type) throws IOException {
+  private static FileResource getFileResourceProto(final String fileName, final FileType type) throws IOException {
     File file = new File(fileName);
     if (file.exists()) {
       // It is a local file and can be added.
@@ -138,7 +140,7 @@ final class JobSubmissionHelper {
         // If it is a directory, create a JAR file of it and add that instead.
         file = toJar(file);
       }
-      return ReefServiceProtos.FileResourceProto.newBuilder()
+      return FileResourceImpl.newBuilder()
           .setName(file.getName())
           .setPath(file.getPath())
           .setType(type)
@@ -150,7 +152,7 @@ final class JobSubmissionHelper {
         final URI uri = new URI(fileName);
         final String path = uri.getPath();
         final String name = path.substring(path.lastIndexOf('/') + 1);
-        return ReefServiceProtos.FileResourceProto.newBuilder()
+        return FileResourceImpl.newBuilder()
             .setName(name)
             .setPath(uri.toString())
             .setType(type)
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/REEFImplementation.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/REEFImplementation.java
index f0074f9..7472fb4 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/REEFImplementation.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/REEFImplementation.java
@@ -22,7 +22,7 @@ import org.apache.reef.annotations.Provided;
 import org.apache.reef.annotations.audience.ClientSide;
 import org.apache.reef.annotations.audience.Private;
 import org.apache.reef.client.REEF;
-import org.apache.reef.proto.ClientRuntimeProtocol.JobSubmissionProto;
+import org.apache.reef.runtime.common.client.api.JobSubmissionEvent;
 import org.apache.reef.runtime.common.client.api.JobSubmissionHandler;
 import org.apache.reef.runtime.common.launch.parameters.ErrorHandlerRID;
 import org.apache.reef.tang.Configuration;
@@ -83,7 +83,7 @@ public final class REEFImplementation implements REEF {
   @Override
   public void submit(final Configuration driverConf) {
     try (LoggingScope ls = this.loggingScopeFactory.reefSubmit()) {
-      final JobSubmissionProto submissionMessage;
+      final JobSubmissionEvent submissionMessage;
       try {
         if (this.clientWireUp.isClientPresent()) {
           submissionMessage = this.jobSubmissionHelper.getJobsubmissionProto(driverConf)
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionEvent.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionEvent.java
new file mode 100644
index 0000000..592c403
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionEvent.java
@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.client.api;
+
+import org.apache.reef.runtime.common.files.FileResource;
+import org.apache.reef.util.Optional;
+
+import java.util.List;
+
+/**
+ * Event from REEF Client -> Driver Runtime
+ */
+public interface JobSubmissionEvent {
+  String getIdentifier();
+  String getRemoteId();
+  String getConfiguration();
+  String getUserName();
+  List<FileResource> getGlobalFileList();
+  List<FileResource> getLocalFileList();
+  Optional<Integer> getDriverMemory();
+  Optional<Integer> getPriority();
+  Optional<String> getQueue();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionEventImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionEventImpl.java
new file mode 100644
index 0000000..c397bb0
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionEventImpl.java
@@ -0,0 +1,161 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.client.api;
+
+import org.apache.reef.runtime.common.files.FileResource;
+import org.apache.reef.util.BuilderUtils;
+import org.apache.reef.util.Optional;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public final class JobSubmissionEventImpl implements JobSubmissionEvent {
+  private final String identifier;
+  private final String remoteId;
+  private final String configuration;
+  private final String userName;
+  private final List<FileResource> globalFileList;
+  private final List<FileResource> localFileList;
+  private final Optional<Integer> driverMemory;
+  private final Optional<Integer> priority;
+  private final Optional<String> queue;
+
+  private JobSubmissionEventImpl(final Builder builder) {
+    this.identifier = BuilderUtils.notNull(builder.identifier);
+    this.remoteId = BuilderUtils.notNull(builder.remoteId);
+    this.configuration = BuilderUtils.notNull(builder.configuration);
+    this.userName = BuilderUtils.notNull(builder.userName);
+    this.globalFileList = BuilderUtils.notNull(builder.globalFileList);
+    this.localFileList = BuilderUtils.notNull(builder.localFileList);
+    this.driverMemory = Optional.ofNullable(builder.driverMemory);
+    this.priority = Optional.ofNullable(builder.priority);
+    this.queue = Optional.ofNullable(builder.queue);
+  }
+
+  @Override
+  public String getIdentifier() {
+    return identifier;
+  }
+
+  @Override
+  public String getRemoteId() {
+    return remoteId;
+  }
+
+  @Override
+  public String getConfiguration() {
+    return configuration;
+  }
+
+  @Override
+  public String getUserName() {
+    return userName;
+  }
+
+  @Override
+  public List<FileResource> getGlobalFileList() {
+    return globalFileList;
+  }
+
+  @Override
+  public List<FileResource> getLocalFileList() {
+    return localFileList;
+  }
+
+  @Override
+  public Optional<Integer> getDriverMemory() {
+    return driverMemory;
+  }
+
+  @Override
+  public Optional<Integer> getPriority() {
+    return priority;
+  }
+
+  @Override
+  public Optional<String> getQueue() {
+    return queue;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<JobSubmissionEvent> {
+    private String identifier;
+    private String remoteId;
+    private String configuration;
+    private String userName;
+    private List<FileResource> globalFileList = new ArrayList<>();
+    private List<FileResource> localFileList = new ArrayList<>();
+    private Integer driverMemory;
+    private Integer priority;
+    private String queue;
+
+    public Builder setIdentifier(final String identifier) {
+      this.identifier = identifier;
+      return this;
+    }
+
+    public Builder setRemoteId(final String remoteId) {
+      this.remoteId = remoteId;
+      return this;
+    }
+
+    public Builder setConfiguration(final String configuration) {
+      this.configuration = configuration;
+      return this;
+    }
+
+    public Builder setUserName(final String userName) {
+      this.userName = userName;
+      return this;
+    }
+
+    public Builder addGlobalFile(final FileResource globalFile) {
+      this.globalFileList.add(globalFile);
+      return this;
+    }
+
+    public Builder addLocalFile(final FileResource localFile) {
+      this.localFileList.add(localFile);
+      return this;
+    }
+
+    public Builder setDriverMemory(final Integer driverMemory) {
+      this.driverMemory = driverMemory;
+      return this;
+    }
+
+    public Builder setPriority(final Integer priority) {
+      this.priority = priority;
+      return this;
+    }
+
+    public Builder setQueue(final String queue) {
+      this.queue = queue;
+      return this;
+    }
+
+    @Override
+    public JobSubmissionEvent build() {
+      return new JobSubmissionEventImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionHandler.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionHandler.java
index af2d064..ae80ba0 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionHandler.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/client/api/JobSubmissionHandler.java
@@ -19,11 +19,10 @@
 package org.apache.reef.runtime.common.client.api;
 
 import org.apache.reef.annotations.audience.RuntimeAuthor;
-import org.apache.reef.proto.ClientRuntimeProtocol.JobSubmissionProto;
 import org.apache.reef.wake.EventHandler;
 
 @RuntimeAuthor
-public interface JobSubmissionHandler extends EventHandler<JobSubmissionProto>, AutoCloseable {
+public interface JobSubmissionHandler extends EventHandler<JobSubmissionEvent>, AutoCloseable {
 
   @Override
   public void close();
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/EvaluatorRequestorImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/EvaluatorRequestorImpl.java
index 940de3c..bff27ab 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/EvaluatorRequestorImpl.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/EvaluatorRequestorImpl.java
@@ -23,7 +23,7 @@ import org.apache.reef.driver.catalog.RackDescriptor;
 import org.apache.reef.driver.catalog.ResourceCatalog;
 import org.apache.reef.driver.evaluator.EvaluatorRequest;
 import org.apache.reef.driver.evaluator.EvaluatorRequestor;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEventImpl;
 import org.apache.reef.runtime.common.driver.api.ResourceRequestHandler;
 import org.apache.reef.util.logging.LoggingScope;
 import org.apache.reef.util.logging.LoggingScopeFactory;
@@ -72,7 +72,7 @@ public final class EvaluatorRequestorImpl implements EvaluatorRequestor {
     }
 
     try (LoggingScope ls = loggingScopeFactory.evaluatorSubmit(req.getNumber())) {
-      final DriverRuntimeProtocol.ResourceRequestProto.Builder request = DriverRuntimeProtocol.ResourceRequestProto
+      final ResourceRequestEventImpl.Builder request = ResourceRequestEventImpl
           .newBuilder()
           .setResourceCount(req.getNumber())
           .setVirtualCores(req.getNumberOfCores())
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchEvent.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchEvent.java
new file mode 100644
index 0000000..3b713d9
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchEvent.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.api;
+
+import org.apache.reef.runtime.common.files.FileResource;
+import org.apache.reef.runtime.common.launch.ProcessType;
+
+import java.util.List;
+
+/**
+ * Event from Driver Process -> Driver Runtime
+ */
+public interface ResourceLaunchEvent {
+    String getIdentifier();
+    String getRemoteId();
+    String getEvaluatorConf();
+    ProcessType getType();
+    List<FileResource> getFileList();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchEventImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchEventImpl.java
new file mode 100644
index 0000000..635ce55
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchEventImpl.java
@@ -0,0 +1,110 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.api;
+
+import org.apache.reef.runtime.common.files.FileResource;
+import org.apache.reef.runtime.common.launch.ProcessType;
+import org.apache.reef.util.BuilderUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public final class ResourceLaunchEventImpl implements ResourceLaunchEvent {
+
+  private final String identifier;
+  private final String remoteId;
+  private final String evaluatorConf;
+  private final ProcessType type;
+  private final List<FileResource> fileList;
+
+  private ResourceLaunchEventImpl(final Builder builder) {
+    this.identifier = BuilderUtils.notNull(builder.identifier);
+    this.remoteId = BuilderUtils.notNull(builder.remoteId);
+    this.evaluatorConf = BuilderUtils.notNull(builder.evaluatorConf);
+    this.type = BuilderUtils.notNull(builder.type);
+    this.fileList = BuilderUtils.notNull(builder.fileList);
+  }
+
+  @Override
+  public String getIdentifier() {
+    return identifier;
+  }
+
+  @Override
+  public String getRemoteId() {
+    return remoteId;
+  }
+
+  @Override
+  public String getEvaluatorConf() {
+    return evaluatorConf;
+  }
+
+  @Override
+  public ProcessType getType() {
+    return type;
+  }
+
+  @Override
+  public List<FileResource> getFileList() {
+    return fileList;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<ResourceLaunchEvent> {
+    private String identifier;
+    private String remoteId;
+    private String evaluatorConf;
+    private ProcessType type;
+    private List<FileResource> fileList = new ArrayList<>();
+
+    public Builder setIdentifier(final String identifier) {
+      this.identifier = identifier;
+      return this;
+    }
+
+    public Builder setRemoteId(final String remoteId) {
+      this.remoteId = remoteId;
+      return this;
+    }
+
+    public Builder setEvaluatorConf(final String evaluatorConf) {
+      this.evaluatorConf = evaluatorConf;
+      return this;
+    }
+
+    public Builder setType(final ProcessType type) {
+      this.type = type;
+      return this;
+    }
+
+    public Builder addFile(final FileResource file) {
+      this.fileList.add(file);
+      return this;
+    }
+
+    @Override
+    public ResourceLaunchEvent build() {
+      return new ResourceLaunchEventImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchHandler.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchHandler.java
index 65c3830..d1e2f62 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchHandler.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceLaunchHandler.java
@@ -19,12 +19,11 @@
 package org.apache.reef.runtime.common.driver.api;
 
 import org.apache.reef.annotations.audience.RuntimeAuthor;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.wake.EventHandler;
 
 /**
  *
  */
 @RuntimeAuthor
-public interface ResourceLaunchHandler extends EventHandler<DriverRuntimeProtocol.ResourceLaunchProto> {
+public interface ResourceLaunchHandler extends EventHandler<ResourceLaunchEvent> {
 }
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseEvent.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseEvent.java
new file mode 100644
index 0000000..beb8b35
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseEvent.java
@@ -0,0 +1,26 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.api;
+
+/**
+ * Event from Driver Process -> Driver Runtime
+ */
+public interface ResourceReleaseEvent {
+  String getIdentifier();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseEventImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseEventImpl.java
new file mode 100644
index 0000000..fec4a56
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseEventImpl.java
@@ -0,0 +1,54 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.api;
+
+import org.apache.reef.util.BuilderUtils;
+
+public final class ResourceReleaseEventImpl implements ResourceReleaseEvent {
+
+  private final String identifier;
+
+  private ResourceReleaseEventImpl(final Builder builder) {
+    this.identifier = BuilderUtils.notNull(builder.identifier);
+  }
+
+  @Override
+  public String getIdentifier() {
+    return identifier;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<ResourceReleaseEvent> {
+
+    private String identifier;
+
+    public Builder setIdentifier(final String identifier) {
+      this.identifier = identifier;
+      return this;
+    }
+
+    @Override
+    public ResourceReleaseEvent build() {
+      return new ResourceReleaseEventImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseHandler.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseHandler.java
index 581eb63..8d55c50 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseHandler.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceReleaseHandler.java
@@ -19,12 +19,11 @@
 package org.apache.reef.runtime.common.driver.api;
 
 import org.apache.reef.annotations.audience.RuntimeAuthor;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.wake.EventHandler;
 
 /**
  *
  */
 @RuntimeAuthor
-public interface ResourceReleaseHandler extends EventHandler<DriverRuntimeProtocol.ResourceReleaseProto> {
+public interface ResourceReleaseHandler extends EventHandler<ResourceReleaseEvent> {
 }
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestEvent.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestEvent.java
new file mode 100644
index 0000000..f094b33
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestEvent.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.api;
+
+import org.apache.reef.util.Optional;
+
+import java.util.List;
+
+/**
+ * Event from Driver Process -> Driver Runtime
+ */
+public interface ResourceRequestEvent {
+  int getResourceCount();
+  List<String> getNodeNameList();
+  List<String> getRackNameList();
+  Optional<Integer> getMemorySize();
+  Optional<Integer> getPriority();
+  Optional<Integer> getVirtualCores();
+  Optional<Boolean> getRelaxLocality();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestEventImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestEventImpl.java
new file mode 100644
index 0000000..a273966
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestEventImpl.java
@@ -0,0 +1,145 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.api;
+
+import org.apache.reef.util.BuilderUtils;
+import org.apache.reef.util.Optional;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public final class ResourceRequestEventImpl implements ResourceRequestEvent {
+  private final int resourceCount;
+  private final List<String> nodeNameList;
+  private final List<String> rackNameList;
+  private final Optional<Integer> memorySize;
+  private final Optional<Integer> priority;
+  private final Optional<Integer> virtualCores;
+  private final Optional<Boolean> relaxLocality;
+
+  private ResourceRequestEventImpl(final Builder builder) {
+    this.resourceCount = BuilderUtils.notNull(builder.resourceCount);
+    this.nodeNameList = BuilderUtils.notNull(builder.nodeNameList);
+    this.rackNameList = BuilderUtils.notNull(builder.rackNameList);
+    this.memorySize = Optional.ofNullable(builder.memorySize);
+    this.priority = Optional.ofNullable(builder.priority);
+    this.virtualCores = Optional.ofNullable(builder.virtualCores);
+    this.relaxLocality = Optional.ofNullable(builder.relaxLocality);
+  }
+
+  @Override
+  public int getResourceCount() {
+    return resourceCount;
+  }
+
+  @Override
+  public List<String> getNodeNameList() {
+    return nodeNameList;
+  }
+
+  @Override
+  public List<String> getRackNameList() {
+    return rackNameList;
+  }
+
+  @Override
+  public Optional<Integer> getMemorySize() {
+    return memorySize;
+  }
+
+  @Override
+  public Optional<Integer> getPriority() {
+    return priority;
+  }
+
+  @Override
+  public Optional<Integer> getVirtualCores() {
+    return virtualCores;
+  }
+
+  @Override
+  public Optional<Boolean> getRelaxLocality() {
+    return relaxLocality;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<ResourceRequestEvent> {
+    private Integer resourceCount;
+    private List<String> nodeNameList = new ArrayList<>();
+    private List<String> rackNameList = new ArrayList<>();
+    private Integer memorySize;
+    private Integer priority;
+    private Integer virtualCores;
+    private Boolean relaxLocality;
+
+    public Builder mergeFrom(final ResourceRequestEvent resourceRequestEvent) {
+      this.resourceCount = resourceRequestEvent.getResourceCount();
+      this.nodeNameList = resourceRequestEvent.getNodeNameList();
+      this.rackNameList = resourceRequestEvent.getRackNameList();
+      this.memorySize = resourceRequestEvent.getMemorySize().orElse(null);
+      this.priority = resourceRequestEvent.getPriority().orElse(null);
+      this.virtualCores = resourceRequestEvent.getVirtualCores().orElse(null);
+      this.relaxLocality = resourceRequestEvent.getRelaxLocality().orElse(null);
+      return this;
+    }
+
+    public Builder setResourceCount(final int resourceCount) {
+      this.resourceCount = resourceCount;
+      return this;
+    }
+
+    public Builder addNodeName(final String nodeName) {
+      this.nodeNameList.add(nodeName);
+      return this;
+    }
+
+    public Builder addRackName(final String rackName) {
+      this.rackNameList.add(rackName);
+      return this;
+    }
+
+    public Builder setMemorySize(final int memorySize) {
+      this.memorySize = memorySize;
+      return this;
+    }
+
+    public Builder setPriority(final int priority) {
+      this.priority = priority;
+      return this;
+    }
+
+    public Builder setVirtualCores(final int virtualCores) {
+      this.virtualCores = virtualCores;
+      return this;
+    }
+
+    public Builder setRelaxLocality(final boolean relaxLocality) {
+      this.relaxLocality = relaxLocality;
+      return this;
+    }
+
+    @Override
+    public ResourceRequestEvent build() {
+      return new ResourceRequestEventImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestHandler.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestHandler.java
index 3d30ec8..6faf938 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestHandler.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/ResourceRequestHandler.java
@@ -19,12 +19,11 @@
 package org.apache.reef.runtime.common.driver.api;
 
 import org.apache.reef.annotations.audience.RuntimeAuthor;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.wake.EventHandler;
 
 /**
  * The evaluator request handler.
  */
 @RuntimeAuthor
-public interface ResourceRequestHandler extends EventHandler<DriverRuntimeProtocol.ResourceRequestProto> {
+public interface ResourceRequestHandler extends EventHandler<ResourceRequestEvent> {
 }
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/RuntimeParameters.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/RuntimeParameters.java
index e847249..9f45b4f 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/RuntimeParameters.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/api/RuntimeParameters.java
@@ -19,7 +19,10 @@
 package org.apache.reef.runtime.common.driver.api;
 
 import org.apache.reef.annotations.audience.RuntimeAuthor;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.RuntimeStatusEvent;
 import org.apache.reef.tang.annotations.Name;
 import org.apache.reef.tang.annotations.NamedParameter;
 import org.apache.reef.wake.EventHandler;
@@ -32,19 +35,19 @@ import org.apache.reef.wake.EventHandler;
 public final class RuntimeParameters {
 
   @NamedParameter(doc = "The resource allocation handler that stub runtimes send along allocated resources e.g., containers.")
-  public final static class ResourceAllocationHandler implements Name<EventHandler<DriverRuntimeProtocol.ResourceAllocationProto>> {
+  public final static class ResourceAllocationHandler implements Name<EventHandler<ResourceAllocationEvent>> {
   }
 
   @NamedParameter(doc = "The node descriptor handler that stub runtimes send along node information.")
-  public final static class NodeDescriptorHandler implements Name<EventHandler<DriverRuntimeProtocol.NodeDescriptorProto>> {
+  public final static class NodeDescriptorHandler implements Name<EventHandler<NodeDescriptorEvent>> {
   }
 
   @NamedParameter(doc = "The resource status handler.")
-  public final static class ResourceStatusHandler implements Name<EventHandler<DriverRuntimeProtocol.ResourceStatusProto>> {
+  public final static class ResourceStatusHandler implements Name<EventHandler<ResourceStatusEvent>> {
   }
 
   @NamedParameter(doc = "The resourcemanager status handler.")
-  public final static class RuntimeStatusHandler implements Name<EventHandler<DriverRuntimeProtocol.RuntimeStatusProto>> {
+  public final static class RuntimeStatusHandler implements Name<EventHandler<RuntimeStatusEvent>> {
   }
 
 }
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/catalog/ResourceCatalogImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/catalog/ResourceCatalogImpl.java
index 6193af4..b01d652 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/catalog/ResourceCatalogImpl.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/catalog/ResourceCatalogImpl.java
@@ -22,7 +22,7 @@ import org.apache.reef.annotations.audience.Private;
 import org.apache.reef.driver.catalog.NodeDescriptor;
 import org.apache.reef.driver.catalog.RackDescriptor;
 import org.apache.reef.driver.catalog.ResourceCatalog;
-import org.apache.reef.proto.DriverRuntimeProtocol.NodeDescriptorProto;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEvent;
 
 import javax.inject.Inject;
 import java.net.InetSocketAddress;
@@ -68,8 +68,8 @@ public final class ResourceCatalogImpl implements ResourceCatalog {
     return this.nodes.get(id);
   }
 
-  public synchronized final void handle(final NodeDescriptorProto node) {
-    final String rack_name = (node.hasRackName() ? node.getRackName() : DEFAULT_RACK);
+  public synchronized final void handle(final NodeDescriptorEvent node) {
+    final String rack_name = node.getRackName().orElse(DEFAULT_RACK);
 
     LOG.log(Level.FINEST, "Catalog new node: id[{0}], rack[{1}], host[{2}], port[{3}], memory[{4}]",
         new Object[]{node.getIdentifier(), rack_name, node.getHostName(), node.getPort(),
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/AllocatedEvaluatorImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/AllocatedEvaluatorImpl.java
index 462d6c9..370844a 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/AllocatedEvaluatorImpl.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/AllocatedEvaluatorImpl.java
@@ -24,9 +24,11 @@ import org.apache.reef.driver.context.ContextConfiguration;
 import org.apache.reef.driver.evaluator.AllocatedEvaluator;
 import org.apache.reef.driver.evaluator.EvaluatorDescriptor;
 import org.apache.reef.driver.evaluator.EvaluatorType;
-import org.apache.reef.proto.DriverRuntimeProtocol;
-import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.runtime.common.driver.api.ResourceLaunchEventImpl;
 import org.apache.reef.runtime.common.evaluator.EvaluatorConfiguration;
+import org.apache.reef.runtime.common.files.FileResourceImpl;
+import org.apache.reef.runtime.common.files.FileType;
+import org.apache.reef.runtime.common.launch.ProcessType;
 import org.apache.reef.tang.Configuration;
 import org.apache.reef.tang.exceptions.BindException;
 import org.apache.reef.tang.formats.ConfigurationModule;
@@ -176,35 +178,35 @@ final class AllocatedEvaluatorImpl implements AllocatedEvaluator {
           evaluatorConfiguration = contextConfigurationModule.build();
         }
 
-        final DriverRuntimeProtocol.ResourceLaunchProto.Builder rbuilder =
-            DriverRuntimeProtocol.ResourceLaunchProto.newBuilder()
+        final ResourceLaunchEventImpl.Builder rbuilder =
+            ResourceLaunchEventImpl.newBuilder()
                 .setIdentifier(this.evaluatorManager.getId())
                 .setRemoteId(this.remoteID)
                 .setEvaluatorConf(configurationSerializer.toString(evaluatorConfiguration));
 
         for (final File file : this.files) {
-          rbuilder.addFile(ReefServiceProtos.FileResourceProto.newBuilder()
-              .setName(file.getName())
-              .setPath(file.getPath())
-              .setType(ReefServiceProtos.FileType.PLAIN)
-              .build());
+          rbuilder.addFile(FileResourceImpl.newBuilder()
+                  .setName(file.getName())
+                  .setPath(file.getPath())
+                  .setType(FileType.PLAIN)
+                  .build());
         }
 
         for (final File lib : this.libraries) {
-          rbuilder.addFile(ReefServiceProtos.FileResourceProto.newBuilder()
-              .setName(lib.getName())
-              .setPath(lib.getPath().toString())
-              .setType(ReefServiceProtos.FileType.LIB)
-              .build());
+          rbuilder.addFile(FileResourceImpl.newBuilder()
+                  .setName(lib.getName())
+                  .setPath(lib.getPath().toString())
+                  .setType(FileType.LIB)
+                  .build());
         }
 
         { // Set the type
           switch (this.evaluatorManager.getEvaluatorDescriptor().getType()) {
             case CLR:
-              rbuilder.setType(ReefServiceProtos.ProcessType.CLR);
+              rbuilder.setType(ProcessType.CLR);
               break;
             default:
-              rbuilder.setType(ReefServiceProtos.ProcessType.JVM);
+              rbuilder.setType(ProcessType.JVM);
           }
         }
 
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/EvaluatorManager.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/EvaluatorManager.java
index a257234..38736f2 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/EvaluatorManager.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/EvaluatorManager.java
@@ -29,16 +29,18 @@ import org.apache.reef.driver.task.FailedTask;
 import org.apache.reef.exception.EvaluatorException;
 import org.apache.reef.exception.EvaluatorKilledByResourceManagerException;
 import org.apache.reef.io.naming.Identifiable;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.proto.EvaluatorRuntimeProtocol;
 import org.apache.reef.proto.ReefServiceProtos;
 import org.apache.reef.runtime.common.DriverRestartCompleted;
 import org.apache.reef.runtime.common.driver.DriverStatusManager;
+import org.apache.reef.runtime.common.driver.api.ResourceLaunchEvent;
+import org.apache.reef.runtime.common.driver.api.ResourceReleaseEventImpl;
 import org.apache.reef.runtime.common.driver.api.ResourceLaunchHandler;
 import org.apache.reef.runtime.common.driver.api.ResourceReleaseHandler;
 import org.apache.reef.runtime.common.driver.context.ContextControlHandler;
 import org.apache.reef.runtime.common.driver.context.ContextRepresenters;
 import org.apache.reef.runtime.common.driver.idle.EventHandlerIdlenessSource;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEvent;
 import org.apache.reef.runtime.common.driver.task.TaskRepresenter;
 import org.apache.reef.runtime.common.utils.ExceptionCodec;
 import org.apache.reef.runtime.common.utils.RemoteManager;
@@ -158,10 +160,10 @@ public final class EvaluatorManager implements Identifiable, AutoCloseable {
     return "REEF_LOCAL_RUNTIME";
   }
 
-  private static boolean isDoneOrFailedOrKilled(final DriverRuntimeProtocol.ResourceStatusProto resourceStatusProto) {
-    return resourceStatusProto.getState() == ReefServiceProtos.State.DONE ||
-        resourceStatusProto.getState() == ReefServiceProtos.State.FAILED ||
-        resourceStatusProto.getState() == ReefServiceProtos.State.KILLED;
+  private static boolean isDoneOrFailedOrKilled(final ResourceStatusEvent resourceStatusEvent) {
+    return resourceStatusEvent.getState() == ReefServiceProtos.State.DONE ||
+        resourceStatusEvent.getState() == ReefServiceProtos.State.FAILED ||
+        resourceStatusEvent.getState() == ReefServiceProtos.State.KILLED;
   }
 
   @Override
@@ -206,7 +208,7 @@ public final class EvaluatorManager implements Identifiable, AutoCloseable {
             @Override
             public void onNext(final Alarm alarm) {
               EvaluatorManager.this.resourceReleaseHandler.onNext(
-                  DriverRuntimeProtocol.ResourceReleaseProto.newBuilder()
+                  ResourceReleaseEventImpl.newBuilder()
                       .setIdentifier(EvaluatorManager.this.evaluatorId).build()
               );
             }
@@ -214,7 +216,7 @@ public final class EvaluatorManager implements Identifiable, AutoCloseable {
         } catch (final IllegalStateException e) {
           LOG.log(Level.WARNING, "Force resource release because the client closed the clock.", e);
           EvaluatorManager.this.resourceReleaseHandler.onNext(
-              DriverRuntimeProtocol.ResourceReleaseProto.newBuilder()
+              ResourceReleaseEventImpl.newBuilder()
                   .setIdentifier(EvaluatorManager.this.evaluatorId).build()
           );
         }
@@ -400,11 +402,11 @@ public final class EvaluatorManager implements Identifiable, AutoCloseable {
     onEvaluatorException(evaluatorException);
   }
 
-  public void onResourceLaunch(final DriverRuntimeProtocol.ResourceLaunchProto resourceLaunchProto) {
+  public void onResourceLaunch(final ResourceLaunchEvent resourceLaunchEvent) {
     synchronized (this.evaluatorDescriptor) {
       if (this.stateManager.isAllocated()) {
         this.stateManager.setSubmitted();
-        this.resourceLaunchHandler.onNext(resourceLaunchProto);
+        this.resourceLaunchHandler.onNext(resourceLaunchEvent);
       } else {
         throw new RuntimeException("Evaluator manager expected " + EvaluatorState.ALLOCATED +
             " state but instead is in state " + this.stateManager);
@@ -471,13 +473,13 @@ public final class EvaluatorManager implements Identifiable, AutoCloseable {
   /**
    * Resource status information from the (actual) resource manager.
    */
-  public void onResourceStatusMessage(final DriverRuntimeProtocol.ResourceStatusProto resourceStatusProto) {
+  public void onResourceStatusMessage(final ResourceStatusEvent resourceStatusEvent) {
     synchronized (this.evaluatorDescriptor) {
-      LOG.log(Level.FINEST, "Resource manager state update: {0}", resourceStatusProto.getState());
+      LOG.log(Level.FINEST, "Resource manager state update: {0}", resourceStatusEvent.getState());
       if (this.stateManager.isDoneOrFailedOrKilled()) {
         LOG.log(Level.FINE, "Ignoring resource status update for Evaluator {0} which is already in state {1}.",
             new Object[]{this.getId(), this.stateManager});
-      } else if (isDoneOrFailedOrKilled(resourceStatusProto) && this.stateManager.isAllocatedOrSubmittedOrRunning()) {
+      } else if (isDoneOrFailedOrKilled(resourceStatusEvent) && this.stateManager.isAllocatedOrSubmittedOrRunning()) {
         // something is wrong. The resource manager reports that the Evaluator is done or failed, but the Driver assumes
         // it to be alive.
         final StringBuilder messageBuilder = new StringBuilder("Evaluator [")
@@ -485,7 +487,7 @@ public final class EvaluatorManager implements Identifiable, AutoCloseable {
             .append("] is assumed to be in state [")
             .append(this.stateManager.toString())
             .append("]. But the resource manager reports it to be in state [")
-            .append(resourceStatusProto.getState())
+            .append(resourceStatusEvent.getState())
             .append("].");
 
         if (this.stateManager.isSubmitted()) {
@@ -503,7 +505,7 @@ public final class EvaluatorManager implements Identifiable, AutoCloseable {
         }
         this.isResourceReleased = true;
 
-        if (resourceStatusProto.getState() == ReefServiceProtos.State.KILLED) {
+        if (resourceStatusEvent.getState() == ReefServiceProtos.State.KILLED) {
           this.onEvaluatorException(new EvaluatorKilledByResourceManagerException(this.evaluatorId, messageBuilder.toString()));
         } else {
           this.onEvaluatorException(new EvaluatorException(this.evaluatorId, messageBuilder.toString()));
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/EvaluatorManagerFactory.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/EvaluatorManagerFactory.java
index d6e7757..e11070b 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/EvaluatorManagerFactory.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/EvaluatorManagerFactory.java
@@ -23,8 +23,9 @@ import org.apache.reef.annotations.audience.Private;
 import org.apache.reef.driver.catalog.NodeDescriptor;
 import org.apache.reef.driver.catalog.ResourceCatalog;
 import org.apache.reef.driver.evaluator.EvaluatorType;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorHandler;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEvent;
 import org.apache.reef.tang.Injector;
 import org.apache.reef.tang.exceptions.BindException;
 import org.apache.reef.tang.exceptions.InjectionException;
@@ -80,26 +81,26 @@ public final class EvaluatorManagerFactory {
   /**
    * Instantiates a new EvaluatorManager based on a resource allocation.
    *
-   * @param resourceAllocationProto
+   * @param resourceAllocationEvent
    * @return
    */
-  public final EvaluatorManager getNewEvaluatorManager(final DriverRuntimeProtocol.ResourceAllocationProto resourceAllocationProto) {
-    final NodeDescriptor nodeDescriptor = this.resourceCatalog.getNode(resourceAllocationProto.getNodeId());
+  public final EvaluatorManager getNewEvaluatorManager(final ResourceAllocationEvent resourceAllocationEvent) {
+    final NodeDescriptor nodeDescriptor = this.resourceCatalog.getNode(resourceAllocationEvent.getNodeId());
 
     if (nodeDescriptor == null) {
-      throw new RuntimeException("Unknown resource: " + resourceAllocationProto.getNodeId());
+      throw new RuntimeException("Unknown resource: " + resourceAllocationEvent.getNodeId());
     }
     final EvaluatorDescriptorImpl evaluatorDescriptor = new EvaluatorDescriptorImpl(nodeDescriptor,
-        EvaluatorType.UNDECIDED, resourceAllocationProto.getResourceMemory(), resourceAllocationProto.getVirtualCores());
+        EvaluatorType.UNDECIDED, resourceAllocationEvent.getResourceMemory(), resourceAllocationEvent.getVirtualCores().get());
 
-    LOG.log(Level.FINEST, "Resource allocation: new evaluator id[{0}]", resourceAllocationProto.getIdentifier());
-    return this.getNewEvaluatorManagerInstance(resourceAllocationProto.getIdentifier(), evaluatorDescriptor);
+    LOG.log(Level.FINEST, "Resource allocation: new evaluator id[{0}]", resourceAllocationEvent.getIdentifier());
+    return this.getNewEvaluatorManagerInstance(resourceAllocationEvent.getIdentifier(), evaluatorDescriptor);
   }
 
-  public final EvaluatorManager createForEvaluatorFailedDuringDriverRestart(final DriverRuntimeProtocol.ResourceStatusProto resourceStatusProto) {
-    if (!resourceStatusProto.getIsFromPreviousDriver()) {
-      throw new RuntimeException("Invalid resourceStatusProto, must be status for resource from previous Driver.");
+  public final EvaluatorManager createForEvaluatorFailedDuringDriverRestart(final ResourceStatusEvent resourceStatusEvent) {
+    if (!resourceStatusEvent.getIsFromPreviousDriver().get()) {
+      throw new RuntimeException("Invalid resourceStatusEvent, must be status for resource from previous Driver.");
     }
-    return getNewEvaluatorManagerInstance(resourceStatusProto.getIdentifier(), new EvaluatorDescriptorImpl(null, EvaluatorType.UNDECIDED, 128, 1));
+    return getNewEvaluatorManagerInstance(resourceStatusEvent.getIdentifier(), new EvaluatorDescriptorImpl(null, EvaluatorType.UNDECIDED, 128, 1));
   }
 }
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/Evaluators.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/Evaluators.java
index dde4e70..664e151 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/Evaluators.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/evaluator/Evaluators.java
@@ -20,7 +20,7 @@ package org.apache.reef.runtime.common.driver.evaluator;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEvent;
 import org.apache.reef.util.Optional;
 import org.apache.reef.util.SingletonAsserter;
 
@@ -106,7 +106,7 @@ public final class Evaluators implements AutoCloseable {
    */
   public synchronized void put(
       final EvaluatorManagerFactory evaluatorManagerFactory,
-      final DriverRuntimeProtocol.ResourceAllocationProto evaluatorMsg) {
+      final ResourceAllocationEvent evaluatorMsg) {
     this.put(evaluatorManagerFactory.getNewEvaluatorManager(evaluatorMsg));
   }
 
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorEvent.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorEvent.java
new file mode 100644
index 0000000..1d9a1fe
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorEvent.java
@@ -0,0 +1,32 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.resourcemanager;
+
+import org.apache.reef.util.Optional;
+
+/**
+ * Event from Driver Runtime -> Driver Process
+ */
+public interface NodeDescriptorEvent {
+  String getIdentifier();
+  String getHostName();
+  int getPort();
+  int getMemorySize();
+  Optional<String> getRackName();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorEventImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorEventImpl.java
new file mode 100644
index 0000000..6dcd9d0
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorEventImpl.java
@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.resourcemanager;
+
+import org.apache.reef.util.BuilderUtils;
+import org.apache.reef.util.Optional;
+
+public final class NodeDescriptorEventImpl implements NodeDescriptorEvent {
+  private final String identifier;
+  private final String hostName;
+  private final int port;
+  private final int memorySize;
+  private final Optional<String> rackName;
+
+  private NodeDescriptorEventImpl(final Builder builder) {
+    this.identifier = BuilderUtils.notNull(builder.identifier);
+    this.hostName = BuilderUtils.notNull(builder.hostName);
+    this.port = BuilderUtils.notNull(builder.port);
+    this.memorySize = BuilderUtils.notNull(builder.memorySize);
+    this.rackName = Optional.ofNullable(builder.rackName);
+  }
+
+  @Override
+  public String getIdentifier() {
+    return identifier;
+  }
+
+  @Override
+  public String getHostName() {
+    return hostName;
+  }
+
+  @Override
+  public int getPort() {
+    return port;
+  }
+
+  @Override
+  public int getMemorySize() {
+    return memorySize;
+  }
+
+  @Override
+  public Optional<String> getRackName() {
+    return rackName;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<NodeDescriptorEvent> {
+    private String identifier;
+    private String hostName;
+    private Integer port;
+    private Integer memorySize;
+    private String rackName;
+
+    public Builder setIdentifier(final String identifier) {
+      this.identifier = identifier;
+      return this;
+    }
+
+    public Builder setHostName(final String hostName) {
+      this.hostName = hostName;
+      return this;
+    }
+
+    public Builder setPort(final int port) {
+      this.port = port;
+      return this;
+    }
+
+    public Builder setMemorySize(final int memorySize) {
+      this.memorySize = memorySize;
+      return this;
+    }
+
+    public Builder setRackName(final String rackName) {
+      this.rackName = rackName;
+      return this;
+    }
+
+    @Override
+    public NodeDescriptorEvent build() {
+      return new NodeDescriptorEventImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorHandler.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorHandler.java
index e5fa95e..4b02f1c 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorHandler.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/NodeDescriptorHandler.java
@@ -20,7 +20,6 @@ package org.apache.reef.runtime.common.driver.resourcemanager;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.runtime.common.driver.catalog.ResourceCatalogImpl;
 import org.apache.reef.wake.EventHandler;
 
@@ -31,7 +30,7 @@ import javax.inject.Inject;
  */
 @Private
 @DriverSide
-public final class NodeDescriptorHandler implements EventHandler<DriverRuntimeProtocol.NodeDescriptorProto> {
+public final class NodeDescriptorHandler implements EventHandler<NodeDescriptorEvent> {
   private final ResourceCatalogImpl resourceCatalog;
 
   @Inject
@@ -40,7 +39,7 @@ public final class NodeDescriptorHandler implements EventHandler<DriverRuntimePr
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.NodeDescriptorProto value) {
+  public void onNext(final NodeDescriptorEvent value) {
     this.resourceCatalog.handle(value);
   }
 }
\ No newline at end of file
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationEvent.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationEvent.java
new file mode 100644
index 0000000..1bc5d5a
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationEvent.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.resourcemanager;
+
+import org.apache.reef.util.Optional;
+
+/**
+ * Event from Driver Runtime -> Driver Process
+ */
+public interface ResourceAllocationEvent {
+  String getIdentifier();
+  int getResourceMemory();
+  String getNodeId();
+  Optional<Integer> getVirtualCores();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationEventImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationEventImpl.java
new file mode 100644
index 0000000..166f3c7
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationEventImpl.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.resourcemanager;
+
+import org.apache.reef.util.BuilderUtils;
+import org.apache.reef.util.Optional;
+
+public final class ResourceAllocationEventImpl implements ResourceAllocationEvent {
+  private final String identifier;
+  private final int resourceMemory;
+  private final String nodeId;
+  private final Optional<Integer> virtualCores;
+
+  private ResourceAllocationEventImpl(final Builder builder) {
+    this.identifier = BuilderUtils.notNull(builder.identifier);
+    this.resourceMemory = BuilderUtils.notNull(builder.resourceMemory);
+    this.nodeId = BuilderUtils.notNull(builder.nodeId);
+    this.virtualCores = Optional.ofNullable(builder.virtualCores);
+  }
+
+  @Override
+  public String getIdentifier() {
+    return identifier;
+  }
+
+  @Override
+  public int getResourceMemory() {
+    return resourceMemory;
+  }
+
+  @Override
+  public String getNodeId() {
+    return nodeId;
+  }
+
+  @Override
+  public Optional<Integer> getVirtualCores() {
+    return virtualCores;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<ResourceAllocationEvent> {
+    private String identifier;
+    private Integer resourceMemory;
+    private String nodeId;
+    private Integer virtualCores;
+
+    public Builder setIdentifier(final String identifier) {
+      this.identifier = identifier;
+      return this;
+    }
+
+    public Builder setResourceMemory(final int resourceMemory) {
+      this.resourceMemory = resourceMemory;
+      return this;
+    }
+
+    public Builder setNodeId(final String nodeId) {
+      this.nodeId = nodeId;
+      return this;
+    }
+
+    public Builder setVirtualCores(final int virtualCores) {
+      this.virtualCores = virtualCores;
+      return this;
+    }
+
+    @Override
+    public ResourceAllocationEvent build() {
+      return new ResourceAllocationEventImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationHandler.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationHandler.java
index 7d0e1e8..cc802e4 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationHandler.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceAllocationHandler.java
@@ -20,7 +20,6 @@ package org.apache.reef.runtime.common.driver.resourcemanager;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.runtime.common.driver.evaluator.EvaluatorManagerFactory;
 import org.apache.reef.runtime.common.driver.evaluator.Evaluators;
 import org.apache.reef.wake.EventHandler;
@@ -33,7 +32,7 @@ import javax.inject.Inject;
 @Private
 @DriverSide
 public final class ResourceAllocationHandler
-    implements EventHandler<DriverRuntimeProtocol.ResourceAllocationProto> {
+    implements EventHandler<ResourceAllocationEvent> {
 
   /**
    * Helper class to make new EvaluatorManager instances,
@@ -54,7 +53,7 @@ public final class ResourceAllocationHandler
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceAllocationProto value) {
+  public void onNext(final ResourceAllocationEvent value) {
     // FIXME: Using this put() method is a temporary fix for the race condition
     // described in issues #828 and #839. Use Evaluators.put(EvaluatorManager) instead
     // when the bug is fixed.
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceManagerStatus.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceManagerStatus.java
index c0db65d..461f1c0 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceManagerStatus.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceManagerStatus.java
@@ -20,7 +20,6 @@ package org.apache.reef.runtime.common.driver.resourcemanager;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.proto.ReefServiceProtos;
 import org.apache.reef.runtime.common.driver.DriverStatusManager;
 import org.apache.reef.runtime.common.driver.idle.DriverIdleManager;
@@ -38,7 +37,7 @@ import java.util.logging.Logger;
  */
 @DriverSide
 @Private
-public final class ResourceManagerStatus implements EventHandler<DriverRuntimeProtocol.RuntimeStatusProto>,
+public final class ResourceManagerStatus implements EventHandler<RuntimeStatusEvent>,
     DriverIdlenessSource {
   private static final Logger LOG = Logger.getLogger(ResourceManagerStatus.class.getName());
 
@@ -64,22 +63,22 @@ public final class ResourceManagerStatus implements EventHandler<DriverRuntimePr
   }
 
   @Override
-  public synchronized void onNext(final DriverRuntimeProtocol.RuntimeStatusProto runtimeStatusProto) {
-    final ReefServiceProtos.State newState = runtimeStatusProto.getState();
-    LOG.log(Level.FINEST, "Runtime status " + runtimeStatusProto);
-    this.outstandingContainerRequests = runtimeStatusProto.getOutstandingContainerRequests();
-    this.containerAllocationCount = runtimeStatusProto.getContainerAllocationCount();
-    this.setState(runtimeStatusProto.getState());
+  public synchronized void onNext(final RuntimeStatusEvent runtimeStatusEvent) {
+    final ReefServiceProtos.State newState = runtimeStatusEvent.getState();
+    LOG.log(Level.FINEST, "Runtime status " + runtimeStatusEvent);
+    this.outstandingContainerRequests = runtimeStatusEvent.getOutstandingContainerRequests().get();
+    this.containerAllocationCount = runtimeStatusEvent.getContainerAllocationList().size();
+    this.setState(runtimeStatusEvent.getState());
 
     switch (newState) {
       case FAILED:
-        this.onRMFailure(runtimeStatusProto);
+        this.onRMFailure(runtimeStatusEvent);
         break;
       case DONE:
-        this.onRMDone(runtimeStatusProto);
+        this.onRMDone(runtimeStatusEvent);
         break;
       case RUNNING:
-        this.onRMRunning(runtimeStatusProto);
+        this.onRMRunning(runtimeStatusEvent);
         break;
     }
   }
@@ -110,19 +109,19 @@ public final class ResourceManagerStatus implements EventHandler<DriverRuntimePr
   }
 
 
-  private synchronized void onRMFailure(final DriverRuntimeProtocol.RuntimeStatusProto runtimeStatusProto) {
-    assert (runtimeStatusProto.getState() == ReefServiceProtos.State.FAILED);
-    this.resourceManagerErrorHandler.onNext(runtimeStatusProto.getError());
+  private synchronized void onRMFailure(final RuntimeStatusEvent runtimeStatusEvent) {
+    assert (runtimeStatusEvent.getState() == ReefServiceProtos.State.FAILED);
+    this.resourceManagerErrorHandler.onNext(runtimeStatusEvent.getError().get());
   }
 
-  private synchronized void onRMDone(final DriverRuntimeProtocol.RuntimeStatusProto runtimeStatusProto) {
-    assert (runtimeStatusProto.getState() == ReefServiceProtos.State.DONE);
+  private synchronized void onRMDone(final RuntimeStatusEvent runtimeStatusEvent) {
+    assert (runtimeStatusEvent.getState() == ReefServiceProtos.State.DONE);
     LOG.log(Level.INFO, "Resource Manager shutdown happened. Triggering Driver shutdown.");
     this.driverStatusManager.onComplete();
   }
 
-  private synchronized void onRMRunning(final DriverRuntimeProtocol.RuntimeStatusProto runtimeStatusProto) {
-    assert (runtimeStatusProto.getState() == ReefServiceProtos.State.RUNNING);
+  private synchronized void onRMRunning(final RuntimeStatusEvent runtimeStatusEvent) {
+    assert (runtimeStatusEvent.getState() == ReefServiceProtos.State.RUNNING);
     if (this.isIdle()) {
       this.driverIdleManager.get().onPotentiallyIdle(IDLE_MESSAGE);
     }
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusEvent.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusEvent.java
new file mode 100644
index 0000000..7168f97
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusEvent.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.resourcemanager;
+
+import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.util.Optional;
+
+/**
+ * Event from Driver Runtime -> Driver Process
+ */
+public interface ResourceStatusEvent {
+  String getIdentifier();
+  ReefServiceProtos.State getState();
+  Optional<String> getDiagnostics();
+  Optional<Integer> getExitCode();
+  Optional<Boolean> getIsFromPreviousDriver();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusEventImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusEventImpl.java
new file mode 100644
index 0000000..bef25dd
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusEventImpl.java
@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.resourcemanager;
+
+import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.util.BuilderUtils;
+import org.apache.reef.util.Optional;
+
+public final class ResourceStatusEventImpl implements ResourceStatusEvent {
+  private final String identifier;
+  private final ReefServiceProtos.State state;
+  private final Optional<String> diagnostics;
+  private final Optional<Integer> exitCode;
+  private final Optional<Boolean> isFromPreviousDriver;
+
+  private ResourceStatusEventImpl(final Builder builder) {
+    this.identifier = BuilderUtils.notNull(builder.identifier);
+    this.state = BuilderUtils.notNull(builder.state);
+    this.diagnostics = Optional.ofNullable(builder.diagnostics);
+    this.exitCode = Optional.ofNullable(builder.exitCode);
+    this.isFromPreviousDriver = Optional.ofNullable(builder.isFromPreviousDriver);
+  }
+
+  @Override
+  public String getIdentifier() {
+    return identifier;
+  }
+
+  @Override
+  public ReefServiceProtos.State getState() {
+    return state;
+  }
+
+  @Override
+  public Optional<String> getDiagnostics() {
+    return diagnostics;
+  }
+
+  @Override
+  public Optional<Integer> getExitCode() {
+    return exitCode;
+  }
+
+  @Override
+  public Optional<Boolean> getIsFromPreviousDriver() {
+    return isFromPreviousDriver;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<ResourceStatusEvent> {
+    private String identifier;
+    private ReefServiceProtos.State state;
+    private String diagnostics;
+    private Integer exitCode;
+    private Boolean isFromPreviousDriver;
+
+    public Builder setIdentifier(final String identifier) {
+      this.identifier = identifier;
+      return this;
+    }
+
+    public Builder setState(final ReefServiceProtos.State state) {
+      this.state = state;
+      return this;
+    }
+
+    public Builder setDiagnostics(final String diagnostics) {
+      this.diagnostics = diagnostics;
+      return this;
+    }
+
+    public Builder setExitCode(final int exitCode) {
+      this.exitCode = exitCode;
+      return this;
+    }
+
+    public Builder setIsFromPreviousDriver(final boolean isFromPreviousDriver) {
+      this.isFromPreviousDriver = isFromPreviousDriver;
+      return this;
+    }
+
+    @Override
+    public ResourceStatusEvent build() {
+      return new ResourceStatusEventImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusHandler.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusHandler.java
index 9abafbd..6d31824 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusHandler.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/ResourceStatusHandler.java
@@ -19,7 +19,6 @@
 package org.apache.reef.runtime.common.driver.resourcemanager;
 
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.runtime.common.driver.evaluator.EvaluatorManager;
 import org.apache.reef.runtime.common.driver.evaluator.EvaluatorManagerFactory;
 import org.apache.reef.runtime.common.driver.evaluator.Evaluators;
@@ -33,7 +32,7 @@ import javax.inject.Inject;
  * about the current state of a given resource. Ideally, we should think the same thing.
  */
 @Private
-public final class ResourceStatusHandler implements EventHandler<DriverRuntimeProtocol.ResourceStatusProto> {
+public final class ResourceStatusHandler implements EventHandler<ResourceStatusEvent> {
 
   private final Evaluators evaluators;
   private final EvaluatorManagerFactory evaluatorManagerFactory;
@@ -49,21 +48,21 @@ public final class ResourceStatusHandler implements EventHandler<DriverRuntimePr
    * about the state of the resource executing an Evaluator; This method simply passes the message
    * off to the referenced EvaluatorManager
    *
-   * @param resourceStatusProto resource status message from the ResourceManager
+   * @param resourceStatusEvent resource status message from the ResourceManager
    */
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceStatusProto resourceStatusProto) {
-    final Optional<EvaluatorManager> evaluatorManager = this.evaluators.get(resourceStatusProto.getIdentifier());
+  public void onNext(final ResourceStatusEvent resourceStatusEvent) {
+    final Optional<EvaluatorManager> evaluatorManager = this.evaluators.get(resourceStatusEvent.getIdentifier());
     if (evaluatorManager.isPresent()) {
-      evaluatorManager.get().onResourceStatusMessage(resourceStatusProto);
+      evaluatorManager.get().onResourceStatusMessage(resourceStatusEvent);
     } else {
-      if (resourceStatusProto.getIsFromPreviousDriver()) {
-        EvaluatorManager previousEvaluatorManager = this.evaluatorManagerFactory.createForEvaluatorFailedDuringDriverRestart(resourceStatusProto);
-        previousEvaluatorManager.onResourceStatusMessage(resourceStatusProto);
+      if (resourceStatusEvent.getIsFromPreviousDriver().get()) {
+        EvaluatorManager previousEvaluatorManager = this.evaluatorManagerFactory.createForEvaluatorFailedDuringDriverRestart(resourceStatusEvent);
+        previousEvaluatorManager.onResourceStatusMessage(resourceStatusEvent);
       } else {
         throw new RuntimeException(
-            "Unknown resource status from evaluator " + resourceStatusProto.getIdentifier() +
-                " with state " + resourceStatusProto.getState()
+            "Unknown resource status from evaluator " + resourceStatusEvent.getIdentifier() +
+                " with state " + resourceStatusEvent.getState()
         );
       }
     }
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/RuntimeStatusEvent.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/RuntimeStatusEvent.java
new file mode 100644
index 0000000..6a7159b
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/RuntimeStatusEvent.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.resourcemanager;
+
+import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.util.Optional;
+
+import java.util.List;
+
+/**
+ * Event from Driver Runtime -> Driver Process
+ */
+public interface RuntimeStatusEvent {
+  String getName();
+  ReefServiceProtos.State getState();
+  List<String> getContainerAllocationList();
+  Optional<ReefServiceProtos.RuntimeErrorProto> getError();
+  Optional<Integer> getOutstandingContainerRequests();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/RuntimeStatusEventImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/RuntimeStatusEventImpl.java
new file mode 100644
index 0000000..6c9fdbc
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/driver/resourcemanager/RuntimeStatusEventImpl.java
@@ -0,0 +1,109 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.driver.resourcemanager;
+
+import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.util.BuilderUtils;
+import org.apache.reef.util.Optional;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public final class RuntimeStatusEventImpl implements RuntimeStatusEvent {
+  private final String name;
+  private final ReefServiceProtos.State state;
+  private final List<String> containerAllocationList;
+  private final Optional<ReefServiceProtos.RuntimeErrorProto> error;
+  private final Optional<Integer> outstandingContainerRequests;
+
+  private RuntimeStatusEventImpl(final Builder builder) {
+    this.name = BuilderUtils.notNull(builder.name);
+    this.state = BuilderUtils.notNull(builder.state);
+    this.containerAllocationList = BuilderUtils.notNull(builder.containerAllocationList);
+    this.error = Optional.ofNullable(builder.error);
+    this.outstandingContainerRequests = Optional.ofNullable(builder.outstandingContainerRequests);
+  }
+
+  @Override
+  public String getName() {
+    return name;
+  }
+
+  @Override
+  public ReefServiceProtos.State getState() {
+    return state;
+  }
+
+  @Override
+  public List<String> getContainerAllocationList() {
+    return containerAllocationList;
+  }
+
+  @Override
+  public Optional<ReefServiceProtos.RuntimeErrorProto> getError() {
+    return error;
+  }
+
+  @Override
+  public Optional<Integer> getOutstandingContainerRequests() {
+    return outstandingContainerRequests;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<RuntimeStatusEvent> {
+    private String name;
+    private ReefServiceProtos.State state;
+    private List<String> containerAllocationList = new ArrayList<>();
+    private ReefServiceProtos.RuntimeErrorProto error;
+    private Integer outstandingContainerRequests;
+
+    public Builder setName(final String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder setState(final ReefServiceProtos.State state) {
+      this.state = state;
+      return this;
+    }
+
+    public Builder addContainerAllocation(final String containerAllocation) {
+      this.containerAllocationList.add(containerAllocation);
+      return this;
+    }
+
+    public Builder setError(final ReefServiceProtos.RuntimeErrorProto error) {
+      this.error = error;
+      return this;
+    }
+
+    public Builder setOutstandingContainerRequests(final int outstandingContainerRequests) {
+      this.outstandingContainerRequests = outstandingContainerRequests;
+      return this;
+    }
+
+    @Override
+    public RuntimeStatusEvent build() {
+      return new RuntimeStatusEventImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileResource.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileResource.java
new file mode 100644
index 0000000..4c9109e
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileResource.java
@@ -0,0 +1,28 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.files;
+
+/**
+ * A File Resource for use by Runtimes
+ */
+public interface FileResource {
+  FileType getType();
+  String getName();
+  String getPath();
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileResourceImpl.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileResourceImpl.java
new file mode 100644
index 0000000..86f07b5
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileResourceImpl.java
@@ -0,0 +1,78 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.files;
+
+import org.apache.reef.util.BuilderUtils;
+
+public final class FileResourceImpl implements FileResource {
+  private final FileType type;
+  private final String name;
+  private final String path;
+
+  private FileResourceImpl(final Builder builder) {
+    this.type = BuilderUtils.notNull(builder.type);
+    this.name = BuilderUtils.notNull(builder.name);
+    this.path = BuilderUtils.notNull(builder.path);
+  }
+
+  @Override
+  public FileType getType() {
+    return type;
+  }
+
+  @Override
+  public String getName() {
+    return name;
+  }
+
+  @Override
+  public String getPath() {
+    return path;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static final class Builder implements org.apache.reef.util.Builder<FileResource> {
+    private FileType type;
+    private String name;
+    private String path;
+
+    public Builder setType(final FileType type) {
+      this.type = type;
+      return this;
+    }
+
+    public Builder setName(final String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder setPath(final String path) {
+      this.path = path;
+      return this;
+    }
+
+    @Override
+    public FileResource build() {
+      return new FileResourceImpl(this);
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileType.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileType.java
new file mode 100644
index 0000000..c000b10
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/FileType.java
@@ -0,0 +1,28 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.files;
+
+/**
+ * Type of a File Resource used by Runtimes
+ */
+public enum FileType {
+  PLAIN,
+  LIB,
+  ARCHIVE
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/JobJarMaker.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/JobJarMaker.java
index 5297158..01b03fa 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/JobJarMaker.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/files/JobJarMaker.java
@@ -21,8 +21,8 @@ package org.apache.reef.runtime.common.files;
 import org.apache.reef.annotations.audience.ClientSide;
 import org.apache.reef.annotations.audience.Private;
 import org.apache.reef.annotations.audience.RuntimeAuthor;
-import org.apache.reef.proto.ClientRuntimeProtocol;
 import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.runtime.common.client.api.JobSubmissionEvent;
 import org.apache.reef.runtime.common.parameters.DeleteTempFiles;
 import org.apache.reef.tang.Configuration;
 import org.apache.reef.tang.annotations.Parameter;
@@ -59,13 +59,13 @@ public final class JobJarMaker {
     this.deleteTempFilesOnExit = deleteTempFilesOnExit;
   }
 
-  public static void copy(final Iterable<ReefServiceProtos.FileResourceProto> files, final File destinationFolder) {
+  public static void copy(final Iterable<FileResource> files, final File destinationFolder) {
 
     if (!destinationFolder.exists()) {
       destinationFolder.mkdirs();
     }
 
-    for (final ReefServiceProtos.FileResourceProto fileProto : files) {
+    for (final FileResource fileProto : files) {
       final File sourceFile = toFile(fileProto);
       final File destinationFile = new File(destinationFolder, fileProto.getName());
       if (destinationFile.exists()) {
@@ -89,12 +89,12 @@ public final class JobJarMaker {
     }
   }
 
-  private static File toFile(final ReefServiceProtos.FileResourceProto fileProto) {
+  private static File toFile(final FileResource fileProto) {
     return new File(fileProto.getPath());
   }
 
   public File createJobSubmissionJAR(
-      final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto,
+      final JobSubmissionEvent jobSubmissionEvent,
       final Configuration driverConfiguration) throws IOException {
 
     // Copy all files to a local job submission folder
@@ -104,8 +104,8 @@ public final class JobJarMaker {
     final File localFolder = new File(jobSubmissionFolder, this.fileNames.getLocalFolderName());
     final File globalFolder = new File(jobSubmissionFolder, this.fileNames.getGlobalFolderName());
 
-    this.copy(jobSubmissionProto.getGlobalFileList(), globalFolder);
-    this.copy(jobSubmissionProto.getLocalFileList(), localFolder);
+    this.copy(jobSubmissionEvent.getGlobalFileList(), globalFolder);
+    this.copy(jobSubmissionEvent.getLocalFileList(), localFolder);
 
     // Store the Driver Configuration in the JAR file.
     this.configurationSerializer.toFile(
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/launch/ProcessType.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/launch/ProcessType.java
new file mode 100644
index 0000000..286174e
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/launch/ProcessType.java
@@ -0,0 +1,27 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.runtime.common.launch;
+
+/**
+ * The type of a process to be launched by the Runtime
+ */
+public enum ProcessType {
+    JVM,
+    CLR
+}
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/launch/REEFMessageCodec.java b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/launch/REEFMessageCodec.java
index 8a81184..39a8f8d 100644
--- a/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/launch/REEFMessageCodec.java
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/runtime/common/launch/REEFMessageCodec.java
@@ -52,9 +52,7 @@ public final class REEFMessageCodec implements Codec<GeneratedMessage> {
   public GeneratedMessage decode(final byte[] bytes) {
     try {
       final REEFProtocol.REEFMessage message = REEFProtocol.REEFMessage.parseFrom(bytes);
-      if (message.hasJobSubmission()) {
-        return message.getJobSubmission();
-      } else if (message.hasJobControl()) {
+      if (message.hasJobControl()) {
         return message.getJobControl();
       } else if (message.hasRuntimeError()) {
         return message.getRuntimeError();
@@ -75,9 +73,7 @@ public final class REEFMessageCodec implements Codec<GeneratedMessage> {
   public byte[] encode(final GeneratedMessage msg) {
     final REEFProtocol.REEFMessage.Builder message = REEFProtocol.REEFMessage.newBuilder();
 
-    if (msg instanceof ClientRuntimeProtocol.JobSubmissionProto) {
-      message.setJobSubmission((ClientRuntimeProtocol.JobSubmissionProto) msg);
-    } else if (msg instanceof ClientRuntimeProtocol.JobControlProto) {
+    if (msg instanceof ClientRuntimeProtocol.JobControlProto) {
       message.setJobControl((ClientRuntimeProtocol.JobControlProto) msg);
     } else if (msg instanceof ReefServiceProtos.RuntimeErrorProto) {
       message.setRuntimeError((ReefServiceProtos.RuntimeErrorProto) msg);
diff --git a/lang/java/reef-common/src/main/java/org/apache/reef/util/BuilderUtils.java b/lang/java/reef-common/src/main/java/org/apache/reef/util/BuilderUtils.java
new file mode 100644
index 0000000..68cd7ce
--- /dev/null
+++ b/lang/java/reef-common/src/main/java/org/apache/reef/util/BuilderUtils.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.reef.util;
+
+/**
+ * Utilities for creating Builders
+ */
+public final class BuilderUtils {
+  /**
+   * Throws a runtime exception if the parameter is null
+   */
+  public static <T> T notNull(final T parameter) {
+    if (parameter == null) {
+      throw new IllegalArgumentException("required parameter");
+    } else {
+      return parameter;
+    }
+  }
+}
diff --git a/lang/java/reef-common/src/main/proto/client_runtime.proto b/lang/java/reef-common/src/main/proto/client_runtime.proto
index 36c648b..2846619 100644
--- a/lang/java/reef-common/src/main/proto/client_runtime.proto
+++ b/lang/java/reef-common/src/main/proto/client_runtime.proto
@@ -23,22 +23,6 @@ import "reef_service_protos.proto";
 
 // Messages from REEF Client -> Driver Runtime
 
-message JobSubmissionProto {
-	required string identifier     = 1; // the job identifier
-	required string remote_id      = 2; // the remote identifier
-	required string configuration  = 5; // the runtime configuration
-	required string user_name      = 6; // the user name
-
-  //optional SIZE   driver_size    = 7; // Removed in REEF 0.3 in favor of driver_memory below.
-  optional int32  driver_memory  = 8;
-  optional int32  priority       = 9;
-  optional string queue          = 10;
-
-	repeated FileResourceProto global_file = 11; // files that should be placed on the driver and all subsequent evaluators
-	repeated FileResourceProto local_File  = 12; // files that should be placed on the driver only
-
-}
-
 enum Signal {
 	SIG_TERMINATE = 1;
 	SIG_SUSPEND   = 2;
diff --git a/lang/java/reef-common/src/main/proto/driver_runtime.proto b/lang/java/reef-common/src/main/proto/driver_runtime.proto
deleted file mode 100644
index 64f5dc1..0000000
--- a/lang/java/reef-common/src/main/proto/driver_runtime.proto
+++ /dev/null
@@ -1,89 +0,0 @@
-// Licensed to the Apache Software Foundation (ASF) under one
-// or more contributor license agreements.  See the NOTICE file
-// distributed with this work for additional information
-// regarding copyright ownership.  The ASF licenses this file
-// to you under the Apache License, Version 2.0 (the
-// "License"); you may not use this file except in compliance
-// with the License.  You may obtain a copy of the License at
-//
-//   http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing,
-// software distributed under the License is distributed on an
-// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, either express or implied.  See the License for the
-// specific language governing permissions and limitations
-// under the License.
-option java_package = "org.apache.reef.proto";
-option java_outer_classname = "DriverRuntimeProtocol";
-option java_generic_services = true;
-option java_generate_equals_and_hash = true;
-
-
-import "reef_service_protos.proto";
-
-// Messages from Driver Runtime -> Driver Process
-
-message DriverProcessRegistrationProto {
-	required string remote_identifier = 1;
-}
-
-
-message NodeDescriptorProto {
-	required string identifier = 1;
-	required string host_name  = 2; // e.g., IP address
-	required int32 port        = 3; // e.g., IP port
-	required int32 memory_size = 4;
-	optional string rack_name  = 5; // e.g., /default-rack
-}
-
-message ResourceAllocationProto {
-	required string identifier     = 1; // e.g., the container id, or the thread id
-	required int32 resource_memory = 2; // megabytes
-	required string node_id        = 3;
-	optional int32 virtual_cores   = 4;
-}
-
-message ResourceStatusProto {
-	required string identifier   = 1;
-	required State  state        = 2;
-	optional string diagnostics  = 3;
-	optional int32  exit_code    = 4;
-	optional bool is_from_previous_driver = 5;
-}
-
-message RuntimeStatusProto {
-   required string name  = 1;   // e.g., local, yarn21
-   required State  state = 2;
-   optional RuntimeErrorProto error = 3; // runtime (e.g., YARN) error
-
-   optional int32 outstanding_container_requests = 5;
-   repeated string container_allocation = 6;
-}
-
-//////////////////////////////////////////////////////
-// Messages from Driver Process -> Driver Runtime
-
-message ResourceRequestProto {
-	// optional SIZE resource_size  = 1; // Removed in REEF 0.3 in favor of memory_size.
-    optional int32 memory_size    = 2; // Memory size of the evaluator in MB
-    optional int32 priority       = 3;
-    optional int32 virtual_cores  = 4;
-    required int32 resource_count = 5;
-	  repeated string node_name     = 6; // a list of specific nodes
-	  repeated string rack_name     = 7; // a list of specific racks
-
-    optional bool relax_locality = 10;
-}
-
-message ResourceReleaseProto {
-	required string identifier = 1;
-}
-
-message ResourceLaunchProto {
-	required string identifier      = 1;
-	required string remote_id       = 2;
-	required string evaluator_conf  = 3;
-  required ProcessType type       = 4;
-	repeated FileResourceProto file = 10;
-}
diff --git a/lang/java/reef-common/src/main/proto/reef_protocol.proto b/lang/java/reef-common/src/main/proto/reef_protocol.proto
index a8c793f..09c4476 100644
--- a/lang/java/reef-common/src/main/proto/reef_protocol.proto
+++ b/lang/java/reef-common/src/main/proto/reef_protocol.proto
@@ -30,8 +30,9 @@ option java_generate_equals_and_hash = true;
 option java_outer_classname = "REEFProtocol";
 
 message REEFMessage {
+    // Field 1 removed
+
     // Messages defined in client_runtime.proto
-    optional JobSubmissionProto jobSubmission = 1;
     optional JobControlProto jobControl = 2;
     // Messages defined in reef_service_protos.proto
     optional RuntimeErrorProto runtimeError = 3;
diff --git a/lang/java/reef-common/src/main/proto/reef_service_protos.proto b/lang/java/reef-common/src/main/proto/reef_service_protos.proto
index 7494737..38d2b39 100644
--- a/lang/java/reef-common/src/main/proto/reef_service_protos.proto
+++ b/lang/java/reef-common/src/main/proto/reef_service_protos.proto
@@ -32,31 +32,6 @@ enum State {
     KILLED = 5;
 }
 
-enum FileType {
-    PLAIN = 0;
-    LIB = 1;
-    ARCHIVE = 2;
-}
-
-// Removed in REEF 0.3 in favor of explicit memory sizes.
-// enum SIZE {
-//    SMALL = 0;
-//    MEDIUM = 1;
-//    LARGE = 2;
-//    XLARGE = 3;
-//}
-
-enum ProcessType {
-    JVM = 0;
-    CLR = 1;
-}
-
-message FileResourceProto {
-    required FileType type = 1;
-    required string name = 2;
-    required string path = 3;
-}
-
 message RuntimeErrorProto {
     required string name = 1; // e.g., local, yarn21
     required string message = 2;
diff --git a/lang/java/reef-common/src/test/java/org/apache/reef/runtime/common/driver/EvaluatorRequestorImplTest.java b/lang/java/reef-common/src/test/java/org/apache/reef/runtime/common/driver/EvaluatorRequestorImplTest.java
index ddbd83b..dce5f50 100644
--- a/lang/java/reef-common/src/test/java/org/apache/reef/runtime/common/driver/EvaluatorRequestorImplTest.java
+++ b/lang/java/reef-common/src/test/java/org/apache/reef/runtime/common/driver/EvaluatorRequestorImplTest.java
@@ -21,7 +21,7 @@ package org.apache.reef.runtime.common.driver;
 import org.apache.reef.driver.catalog.ResourceCatalog;
 import org.apache.reef.driver.evaluator.EvaluatorRequest;
 import org.apache.reef.driver.evaluator.EvaluatorRequestor;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceRequestHandler;
 import org.apache.reef.tang.Tang;
 import org.apache.reef.tang.exceptions.InjectionException;
@@ -53,8 +53,8 @@ public class EvaluatorRequestorImplTest {
     final DummyRequestHandler requestHandler = new DummyRequestHandler();
     final EvaluatorRequestor evaluatorRequestor = new EvaluatorRequestorImpl(resourceCatalog, requestHandler, loggingScopeFactory);
     evaluatorRequestor.submit(EvaluatorRequest.newBuilder().setMemory(memory).build());
-    Assert.assertEquals("Memory request did not make it", requestHandler.get().getMemorySize(), memory);
-    Assert.assertEquals("Number of requests did not make it", requestHandler.get().getResourceCount(), 1);
+    Assert.assertEquals("Memory request did not make it", memory, requestHandler.get().getMemorySize().get().intValue());
+    Assert.assertEquals("Number of requests did not make it", 1, requestHandler.get().getResourceCount());
   }
 
   /**
@@ -67,8 +67,8 @@ public class EvaluatorRequestorImplTest {
     final DummyRequestHandler requestHandler = new DummyRequestHandler();
     final EvaluatorRequestor evaluatorRequestor = new EvaluatorRequestorImpl(resourceCatalog, requestHandler, loggingScopeFactory);
     evaluatorRequestor.submit(EvaluatorRequest.newBuilder().setMemory(memory).setNumber(count).build());
-    Assert.assertEquals("Memory request did not make it", requestHandler.get().getMemorySize(), memory);
-    Assert.assertEquals("Number of requests did not make it", requestHandler.get().getResourceCount(), count);
+    Assert.assertEquals("Memory request did not make it", memory, requestHandler.get().getMemorySize().get().intValue());
+    Assert.assertEquals("Number of requests did not make it", count, requestHandler.get().getResourceCount());
   }
 
   /**
@@ -96,14 +96,14 @@ public class EvaluatorRequestorImplTest {
   }
 
   private class DummyRequestHandler implements ResourceRequestHandler {
-    private DriverRuntimeProtocol.ResourceRequestProto request;
+    private ResourceRequestEvent request;
 
     @Override
-    public void onNext(DriverRuntimeProtocol.ResourceRequestProto resourceRequestProto) {
-      this.request = resourceRequestProto;
+    public void onNext(final ResourceRequestEvent resourceRequestEvent) {
+      this.request = resourceRequestEvent;
     }
 
-    public DriverRuntimeProtocol.ResourceRequestProto get() {
+    public ResourceRequestEvent get() {
       return this.request;
     }
   }
diff --git a/lang/java/reef-common/src/test/java/org/apache/reef/runtime/common/driver/catalog/CatalogTest.java b/lang/java/reef-common/src/test/java/org/apache/reef/runtime/common/driver/catalog/CatalogTest.java
index 66203b2..72503d0 100644
--- a/lang/java/reef-common/src/test/java/org/apache/reef/runtime/common/driver/catalog/CatalogTest.java
+++ b/lang/java/reef-common/src/test/java/org/apache/reef/runtime/common/driver/catalog/CatalogTest.java
@@ -18,7 +18,7 @@
  */
 package org.apache.reef.runtime.common.driver.catalog;
 
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEventImpl;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -35,7 +35,7 @@ public final class CatalogTest {
     final ResourceCatalogImpl catalog = new ResourceCatalogImpl();
 
     for (int i = 0; i < nodes; i++) {
-      catalog.handle(DriverRuntimeProtocol.NodeDescriptorProto.newBuilder()
+      catalog.handle(NodeDescriptorEventImpl.newBuilder()
           .setRackName("test-rack")
           .setHostName("test-" + i)
           .setPort(0)
diff --git a/lang/java/reef-runtime-hdinsight/src/main/java/org/apache/reef/runtime/hdinsight/client/HDInsightJobSubmissionHandler.java b/lang/java/reef-runtime-hdinsight/src/main/java/org/apache/reef/runtime/hdinsight/client/HDInsightJobSubmissionHandler.java
index 7ac314a..88fcf33 100644
--- a/lang/java/reef-runtime-hdinsight/src/main/java/org/apache/reef/runtime/hdinsight/client/HDInsightJobSubmissionHandler.java
+++ b/lang/java/reef-runtime-hdinsight/src/main/java/org/apache/reef/runtime/hdinsight/client/HDInsightJobSubmissionHandler.java
@@ -22,7 +22,7 @@ import org.apache.commons.lang.StringUtils;
 import org.apache.hadoop.yarn.api.ApplicationConstants;
 import org.apache.reef.annotations.audience.ClientSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.ClientRuntimeProtocol;
+import org.apache.reef.runtime.common.client.api.JobSubmissionEvent;
 import org.apache.reef.runtime.common.client.api.JobSubmissionHandler;
 import org.apache.reef.runtime.common.files.ClasspathProvider;
 import org.apache.reef.runtime.common.files.JobJarMaker;
@@ -82,7 +82,7 @@ public final class HDInsightJobSubmissionHandler implements JobSubmissionHandler
   }
 
   @Override
-  public void onNext(final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto) {
+  public void onNext(final JobSubmissionEvent jobSubmissionEvent) {
 
     try {
 
@@ -96,25 +96,25 @@ public final class HDInsightJobSubmissionHandler implements JobSubmissionHandler
 
       LOG.log(Level.FINE, "Assembling Configuration for the Driver.");
       final Configuration driverConfiguration =
-          makeDriverConfiguration(jobSubmissionProto, applicationID.getId(), jobFolderURL);
+          makeDriverConfiguration(jobSubmissionEvent, applicationID.getId(), jobFolderURL);
 
       LOG.log(Level.FINE, "Making Job JAR.");
       final File jobSubmissionJarFile =
-          this.jobJarMaker.createJobSubmissionJAR(jobSubmissionProto, driverConfiguration);
+          this.jobJarMaker.createJobSubmissionJAR(jobSubmissionEvent, driverConfiguration);
 
       LOG.log(Level.FINE, "Uploading Job JAR to Azure.");
       final FileResource uploadedFile = this.uploader.uploadFile(jobSubmissionJarFile);
 
       LOG.log(Level.FINE, "Assembling application submission.");
-      final String command = getCommandString(jobSubmissionProto);
+      final String command = getCommandString(jobSubmissionEvent);
 
       final ApplicationSubmission applicationSubmission = new ApplicationSubmission()
           .setApplicationId(applicationID.getId())
-          .setApplicationName(jobSubmissionProto.getIdentifier())
-          .setResource(getResource(jobSubmissionProto))
+          .setApplicationName(jobSubmissionEvent.getIdentifier())
+          .setResource(getResource(jobSubmissionEvent))
           .setContainerInfo(new ContainerInfo()
-              .addFileResource(this.filenames.getREEFFolderName(), uploadedFile)
-              .addCommand(command));
+                  .addFileResource(this.filenames.getREEFFolderName(), uploadedFile)
+                  .addCommand(command));
 
       this.hdInsightInstance.submitApplication(applicationSubmission);
       LOG.log(Level.INFO, "Submitted application to HDInsight. The application id is: {0}", applicationID.getId());
@@ -126,13 +126,13 @@ public final class HDInsightJobSubmissionHandler implements JobSubmissionHandler
   }
 
   /**
-   * Extracts the resource demands from the jobSubmissionProto.
+   * Extracts the resource demands from the jobSubmissionEvent.
    */
   private final Resource getResource(
-      final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto) {
+      final JobSubmissionEvent jobSubmissionEvent) {
 
     return new Resource()
-        .setMemory(String.valueOf(jobSubmissionProto.getDriverMemory()))
+        .setMemory(String.valueOf(jobSubmissionEvent.getDriverMemory().get()))
         .setvCores("1");
   }
 
@@ -140,30 +140,30 @@ public final class HDInsightJobSubmissionHandler implements JobSubmissionHandler
    * Assembles the command to execute the Driver.
    */
   private String getCommandString(
-      final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto) {
-    return StringUtils.join(getCommandList(jobSubmissionProto), ' ');
+      final JobSubmissionEvent jobSubmissionEvent) {
+    return StringUtils.join(getCommandList(jobSubmissionEvent), ' ');
   }
 
   /**
    * Assembles the command to execute the Driver in list form.
    */
   private List<String> getCommandList(
-      final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto) {
+      final JobSubmissionEvent jobSubmissionEvent) {
 
     return new JavaLaunchCommandBuilder()
         .setJavaPath("%JAVA_HOME%/bin/java")
-        .setErrorHandlerRID(jobSubmissionProto.getRemoteId())
-        .setLaunchID(jobSubmissionProto.getIdentifier())
+        .setErrorHandlerRID(jobSubmissionEvent.getRemoteId())
+        .setLaunchID(jobSubmissionEvent.getIdentifier())
         .setConfigurationFileName(this.filenames.getDriverConfigurationPath())
         .setClassPath(this.classpath.getDriverClasspath())
-        .setMemory(jobSubmissionProto.getDriverMemory())
+        .setMemory(jobSubmissionEvent.getDriverMemory().get())
         .setStandardErr(ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/" + this.filenames.getDriverStderrFileName())
         .setStandardOut(ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/" + this.filenames.getDriverStdoutFileName())
         .build();
   }
 
   private Configuration makeDriverConfiguration(
-      final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto,
+      final JobSubmissionEvent jobSubmissionEvent,
       final String applicationId,
       final String jobFolderURL) throws IOException {
 
@@ -174,7 +174,7 @@ public final class HDInsightJobSubmissionHandler implements JobSubmissionHandler
         .build();
 
     return Configurations.merge(
-        this.configurationSerializer.fromString(jobSubmissionProto.getConfiguration()),
+        this.configurationSerializer.fromString(jobSubmissionEvent.getConfiguration()),
         hdinsightDriverConfiguration);
   }
 }
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/client/DriverFiles.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/client/DriverFiles.java
index c54f9e0..1eecd2a 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/client/DriverFiles.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/client/DriverFiles.java
@@ -18,8 +18,9 @@
  */
 package org.apache.reef.runtime.local.client;
 
-import org.apache.reef.proto.ClientRuntimeProtocol;
-import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.runtime.common.client.api.JobSubmissionEvent;
+import org.apache.reef.runtime.common.files.FileResource;
+import org.apache.reef.runtime.common.files.FileType;
 import org.apache.reef.runtime.common.files.REEFFileNames;
 import org.apache.reef.tang.formats.ConfigurationModule;
 import org.apache.reef.tang.formats.OptionalParameter;
@@ -51,28 +52,28 @@ final class DriverFiles {
   /**
    * Instantiates an instance based on the given JobSubmissionProto.
    *
-   * @param jobSubmissionProto the JobSubmissionProto to parse.
+   * @param jobSubmissionEvent the JobSubmissionProto to parse.
    * @return a DriverFiles instance pre-populated with the information from the given JobSubmissionProto.
    * @throws IOException
    */
   public static DriverFiles fromJobSubmission(
-      final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto,
+      final JobSubmissionEvent jobSubmissionEvent,
       final REEFFileNames fileNames) throws IOException {
 
     final DriverFiles driverFiles = new DriverFiles(fileNames);
 
-    for (final ReefServiceProtos.FileResourceProto frp : jobSubmissionProto.getGlobalFileList()) {
+    for (final FileResource frp : jobSubmissionEvent.getGlobalFileList()) {
       final File f = new File(frp.getPath());
-      if (frp.getType() == ReefServiceProtos.FileType.LIB) {
+      if (frp.getType() == FileType.LIB) {
         driverFiles.addGlobalLib(f);
       } else {
         driverFiles.addGlobalFile(f);
       }
     }
 
-    for (final ReefServiceProtos.FileResourceProto frp : jobSubmissionProto.getLocalFileList()) {
+    for (final FileResource frp : jobSubmissionEvent.getLocalFileList()) {
       final File f = new File(frp.getPath());
-      if (frp.getType() == ReefServiceProtos.FileType.LIB) {
+      if (frp.getType() == FileType.LIB) {
         driverFiles.addLocalLib(f);
       } else {
         driverFiles.addLocalFile(f);
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/client/LocalJobSubmissionHandler.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/client/LocalJobSubmissionHandler.java
index d417fce..7a8f7d3 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/client/LocalJobSubmissionHandler.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/client/LocalJobSubmissionHandler.java
@@ -20,14 +20,11 @@ package org.apache.reef.runtime.local.client;
 
 import org.apache.reef.annotations.audience.ClientSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.ClientRuntimeProtocol;
+import org.apache.reef.runtime.common.client.api.JobSubmissionEvent;
 import org.apache.reef.runtime.common.client.api.JobSubmissionHandler;
 import org.apache.reef.runtime.common.files.ClasspathProvider;
 import org.apache.reef.runtime.common.files.REEFFileNames;
-import org.apache.reef.runtime.common.launch.JavaLaunchCommandBuilder;
 import org.apache.reef.runtime.local.client.parameters.RootFolder;
-import org.apache.reef.runtime.local.process.LoggingRunnableProcessObserver;
-import org.apache.reef.runtime.local.process.RunnableProcess;
 import org.apache.reef.tang.Configuration;
 import org.apache.reef.tang.annotations.Parameter;
 import org.apache.reef.tang.formats.ConfigurationSerializer;
@@ -89,7 +86,7 @@ final class LocalJobSubmissionHandler implements JobSubmissionHandler {
   }
 
   @Override
-  public final void onNext(final ClientRuntimeProtocol.JobSubmissionProto t) {
+  public final void onNext(final JobSubmissionEvent t) {
     try (final LoggingScope lf = loggingScopeFactory.localJobSubmission()) {
       try {
         LOG.log(Level.FINEST, "Starting local job {0}", t.getIdentifier());
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ContainerManager.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ContainerManager.java
index c1a746c..4ef09d5 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ContainerManager.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ContainerManager.java
@@ -21,9 +21,10 @@ package org.apache.reef.runtime.local.driver;
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
 import org.apache.reef.client.FailedRuntime;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.proto.ReefServiceProtos;
 import org.apache.reef.runtime.common.driver.api.RuntimeParameters;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEventImpl;
 import org.apache.reef.runtime.common.files.REEFFileNames;
 import org.apache.reef.runtime.common.utils.RemoteManager;
 import org.apache.reef.runtime.local.client.parameters.MaxNumberOfEvaluators;
@@ -68,7 +69,7 @@ final class ContainerManager implements AutoCloseable {
 
   private final String errorHandlerRID;
   private final int capacity;
-  private final EventHandler<DriverRuntimeProtocol.NodeDescriptorProto> nodeDescriptorHandler;
+  private final EventHandler<NodeDescriptorEvent> nodeDescriptorHandler;
   private final File rootFolder;
   private final REEFFileNames fileNames;
   private final ReefRunnableProcessObserver processObserver;
@@ -81,7 +82,7 @@ final class ContainerManager implements AutoCloseable {
       final @Parameter(MaxNumberOfEvaluators.class) int capacity,
       final @Parameter(RootFolder.class) String rootFolderName,
       final @Parameter(RuntimeParameters.NodeDescriptorHandler.class)
-      EventHandler<DriverRuntimeProtocol.NodeDescriptorProto> nodeDescriptorHandler,
+      EventHandler<NodeDescriptorEvent> nodeDescriptorHandler,
       final ReefRunnableProcessObserver processObserver) {
 
     this.capacity = capacity;
@@ -128,7 +129,7 @@ final class ContainerManager implements AutoCloseable {
     for (int i = 0; i < capacity; i++) {
       final String id = idmaker.getNextID();
       this.freeNodeList.add(id);
-      nodeDescriptorHandler.onNext(DriverRuntimeProtocol.NodeDescriptorProto.newBuilder()
+      nodeDescriptorHandler.onNext(NodeDescriptorEventImpl.newBuilder()
           .setIdentifier(id)
           .setRackName("/default-rack")
           .setHostName(NetUtils.getLocalAddress())
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceLaunchHandler.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceLaunchHandler.java
index be3ead8..bf4a177 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceLaunchHandler.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceLaunchHandler.java
@@ -20,7 +20,7 @@ package org.apache.reef.runtime.local.driver;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceLaunchEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceLaunchHandler;
 
 import javax.inject.Inject;
@@ -40,7 +40,7 @@ final class LocalResourceLaunchHandler implements ResourceLaunchHandler {
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceLaunchProto t) {
+  public void onNext(final ResourceLaunchEvent t) {
     this.resourceManager.onResourceLaunchRequest(t);
   }
 }
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceReleaseHandler.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceReleaseHandler.java
index 04c2730..514a297 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceReleaseHandler.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceReleaseHandler.java
@@ -20,7 +20,7 @@ package org.apache.reef.runtime.local.driver;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceReleaseEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceReleaseHandler;
 
 import javax.inject.Inject;
@@ -41,7 +41,7 @@ public final class LocalResourceReleaseHandler implements ResourceReleaseHandler
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceReleaseProto t) {
+  public void onNext(final ResourceReleaseEvent t) {
     this.resourceManager.onResourceReleaseRequest(t);
   }
 }
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceRequestHandler.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceRequestHandler.java
index a08b05c..99ae748 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceRequestHandler.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/LocalResourceRequestHandler.java
@@ -20,7 +20,7 @@ package org.apache.reef.runtime.local.driver;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceRequestHandler;
 
 import javax.inject.Inject;
@@ -40,7 +40,7 @@ final class LocalResourceRequestHandler implements ResourceRequestHandler {
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceRequestProto t) {
+  public void onNext(final ResourceRequestEvent t) {
     this.resourceManager.onResourceRequest(t);
   }
 }
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceManager.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceManager.java
index e30eba3..5a837f1 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceManager.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceManager.java
@@ -20,10 +20,17 @@ package org.apache.reef.runtime.local.driver;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.proto.ReefServiceProtos;
+import org.apache.reef.runtime.common.driver.api.ResourceLaunchEvent;
+import org.apache.reef.runtime.common.driver.api.ResourceReleaseEvent;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEvent;
 import org.apache.reef.runtime.common.driver.api.RuntimeParameters;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEventImpl;
+import org.apache.reef.runtime.common.driver.resourcemanager.RuntimeStatusEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.RuntimeStatusEventImpl;
 import org.apache.reef.runtime.common.files.ClasspathProvider;
+import org.apache.reef.runtime.common.files.FileResource;
 import org.apache.reef.runtime.common.files.REEFFileNames;
 import org.apache.reef.runtime.common.launch.CLRLaunchCommandBuilder;
 import org.apache.reef.runtime.common.launch.JavaLaunchCommandBuilder;
@@ -58,9 +65,9 @@ public final class ResourceManager {
 
   private final ResourceRequestQueue requestQueue = new ResourceRequestQueue();
 
-  private final EventHandler<DriverRuntimeProtocol.ResourceAllocationProto> allocationHandler;
+  private final EventHandler<ResourceAllocationEvent> allocationHandler;
   private final ContainerManager theContainers;
-  private final EventHandler<DriverRuntimeProtocol.RuntimeStatusProto> runtimeStatusHandlerEventHandler;
+  private final EventHandler<RuntimeStatusEvent> runtimeStatusHandlerEventHandler;
   private final int defaultMemorySize;
   private final int defaultNumberOfCores;
   private final ConfigurationSerializer configurationSerializer;
@@ -73,8 +80,8 @@ public final class ResourceManager {
   @Inject
   ResourceManager(
       final ContainerManager containerManager,
-      final @Parameter(RuntimeParameters.ResourceAllocationHandler.class) EventHandler<DriverRuntimeProtocol.ResourceAllocationProto> allocationHandler,
-      final @Parameter(RuntimeParameters.RuntimeStatusHandler.class) EventHandler<DriverRuntimeProtocol.RuntimeStatusProto> runtimeStatusHandlerEventHandler,
+      final @Parameter(RuntimeParameters.ResourceAllocationHandler.class) EventHandler<ResourceAllocationEvent> allocationHandler,
+      final @Parameter(RuntimeParameters.RuntimeStatusHandler.class) EventHandler<RuntimeStatusEvent> runtimeStatusHandlerEventHandler,
       final @Parameter(DefaultMemorySize.class) int defaultMemorySize,
       final @Parameter(DefaultNumberOfCores.class) int defaultNumberOfCores,
       final @Parameter(JVMHeapSlack.class) double jvmHeapSlack,
@@ -105,9 +112,9 @@ public final class ResourceManager {
    * @param launchRequest the ResourceLaunchProto to parse
    * @return a list of files set in the given ResourceLaunchProto
    */
-  private static List<File> getLocalFiles(final DriverRuntimeProtocol.ResourceLaunchProto launchRequest) {
+  private static List<File> getLocalFiles(final ResourceLaunchEvent launchRequest) {
     final List<File> files = new ArrayList<>();  // Libraries local to this evaluator
-    for (final ReefServiceProtos.FileResourceProto frp : launchRequest.getFileList()) {
+    for (final FileResource frp : launchRequest.getFileList()) {
       files.add(new File(frp.getPath()).getAbsoluteFile());
     }
     return files;
@@ -120,7 +127,7 @@ public final class ResourceManager {
    *
    * @param resourceRequest the resource request to be handled.
    */
-  final void onResourceRequest(final DriverRuntimeProtocol.ResourceRequestProto resourceRequest) {
+  final void onResourceRequest(final ResourceRequestEvent resourceRequest) {
     synchronized (this.theContainers) {
       this.requestQueue.add(new ResourceRequest(resourceRequest));
       this.checkRequestQueue();
@@ -132,7 +139,7 @@ public final class ResourceManager {
    *
    * @param releaseRequest the release request to be processed
    */
-  final void onResourceReleaseRequest(final DriverRuntimeProtocol.ResourceReleaseProto releaseRequest) {
+  final void onResourceReleaseRequest(final ResourceReleaseEvent releaseRequest) {
     synchronized (this.theContainers) {
       LOG.log(Level.FINEST, "Release container: {0}", releaseRequest.getIdentifier());
       this.theContainers.release(releaseRequest.getIdentifier());
@@ -158,7 +165,7 @@ public final class ResourceManager {
    * @param launchRequest the launch request to be processed.
    */
   final void onResourceLaunchRequest(
-      final DriverRuntimeProtocol.ResourceLaunchProto launchRequest) {
+      final ResourceLaunchEvent launchRequest) {
 
     synchronized (this.theContainers) {
 
@@ -218,16 +225,16 @@ public final class ResourceManager {
     if (this.theContainers.hasContainerAvailable() && this.requestQueue.hasOutStandingRequests()) {
 
       // Record the satisfaction of one request and get its details.
-      final DriverRuntimeProtocol.ResourceRequestProto requestProto = this.requestQueue.satisfyOne();
+      final ResourceRequestEvent requestEvent = this.requestQueue.satisfyOne();
 
       // Allocate a Container
       final Container container = this.theContainers.allocateOne(
-          requestProto.hasMemorySize() ? requestProto.getMemorySize() : this.defaultMemorySize,
-          requestProto.hasVirtualCores() ? requestProto.getVirtualCores() : this.defaultNumberOfCores);
+              requestEvent.getMemorySize().orElse(this.defaultMemorySize),
+              requestEvent.getVirtualCores().orElse(this.defaultNumberOfCores));
 
       // Tell the receivers about it
-      final DriverRuntimeProtocol.ResourceAllocationProto alloc =
-          DriverRuntimeProtocol.ResourceAllocationProto.newBuilder()
+      final ResourceAllocationEvent alloc =
+          ResourceAllocationEventImpl.newBuilder()
               .setIdentifier(container.getContainerID())
               .setNodeId(container.getNodeID())
               .setResourceMemory(container.getMemory())
@@ -250,16 +257,18 @@ public final class ResourceManager {
 
   private void sendRuntimeStatus() {
 
-    final DriverRuntimeProtocol.RuntimeStatusProto msg =
-        DriverRuntimeProtocol.RuntimeStatusProto.newBuilder()
+    final RuntimeStatusEventImpl.Builder builder =
+        RuntimeStatusEventImpl.newBuilder()
             .setName("LOCAL")
             .setState(ReefServiceProtos.State.RUNNING)
-            .setOutstandingContainerRequests(this.requestQueue.getNumberOfOutstandingRequests())
-            .addAllContainerAllocation(this.theContainers.getAllocatedContainerIDs())
-            .build();
+            .setOutstandingContainerRequests(this.requestQueue.getNumberOfOutstandingRequests());
+    for (final String containerAllocation : this.theContainers.getAllocatedContainerIDs()) {
+      builder.addContainerAllocation(containerAllocation);
+    }
+    final RuntimeStatusEvent msg = builder.build();
 
     LOG.log(Level.INFO, "Allocated: {0}, Outstanding requests: {1}",
-        new Object[]{msg.getContainerAllocationCount(), msg.getOutstandingContainerRequests()});
+        new Object[]{msg.getContainerAllocationList().size(), msg.getOutstandingContainerRequests()});
     this.runtimeStatusHandlerEventHandler.onNext(msg);
   }
 }
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceRequest.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceRequest.java
index bbb20a3..4b275cb 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceRequest.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceRequest.java
@@ -20,21 +20,21 @@ package org.apache.reef.runtime.local.driver;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEvent;
 
 /**
- * Manages a ResourceRequestProto and its satisfaction.
+ * Manages a ResourceRequestEvent and its satisfaction.
  */
 @Private
 @DriverSide
 final class ResourceRequest {
 
-  private final DriverRuntimeProtocol.ResourceRequestProto req;
+  private final ResourceRequestEvent req;
   private int satisfied = 0;
 
-  ResourceRequest(final DriverRuntimeProtocol.ResourceRequestProto req) {
+  ResourceRequest(final ResourceRequestEvent req) {
     if (null == req) {
-      throw new IllegalArgumentException("Can't instantiate a ResourceRequest without a ResourceRequestProto");
+      throw new IllegalArgumentException("Can't instantiate a ResourceRequest without a ResourceRequestEvent");
     }
     this.req = req;
   }
@@ -57,7 +57,7 @@ final class ResourceRequest {
     return this.satisfied == req.getResourceCount();
   }
 
-  final DriverRuntimeProtocol.ResourceRequestProto getRequestProto() {
+  final ResourceRequestEvent getRequestProto() {
     return this.req;
   }
 }
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceRequestQueue.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceRequestQueue.java
index c2a87ff..dcebe20 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceRequestQueue.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/driver/ResourceRequestQueue.java
@@ -20,7 +20,7 @@ package org.apache.reef.runtime.local.driver;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEvent;
 
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -54,7 +54,7 @@ final class ResourceRequestQueue {
    * Satisfies one resource for the front-most request. If that satisfies the
    * request, it is removed from the queue.
    */
-  final synchronized DriverRuntimeProtocol.ResourceRequestProto satisfyOne() {
+  final synchronized ResourceRequestEvent satisfyOne() {
     final ResourceRequest req = this.requestQueue.element();
     req.satisfyOne();
     if (req.isSatisfied()) {
diff --git a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/process/ReefRunnableProcessObserver.java b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/process/ReefRunnableProcessObserver.java
index 36ee916..3d5051a 100644
--- a/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/process/ReefRunnableProcessObserver.java
+++ b/lang/java/reef-runtime-local/src/main/java/org/apache/reef/runtime/local/process/ReefRunnableProcessObserver.java
@@ -19,9 +19,10 @@
 package org.apache.reef.runtime.local.process;
 
 import net.jcip.annotations.ThreadSafe;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.proto.ReefServiceProtos;
 import org.apache.reef.runtime.common.driver.api.RuntimeParameters;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEventImpl;
 import org.apache.reef.runtime.local.driver.ResourceManager;
 import org.apache.reef.tang.InjectionFuture;
 import org.apache.reef.tang.annotations.Parameter;
@@ -38,7 +39,7 @@ import java.util.logging.Logger;
 public final class ReefRunnableProcessObserver implements RunnableProcessObserver {
   private static final Logger LOG = Logger.getLogger(ReefRunnableProcessObserver.class.getName());
 
-  private final EventHandler<DriverRuntimeProtocol.ResourceStatusProto> resourceStatusHandler;
+  private final EventHandler<ResourceStatusEvent> resourceStatusHandler;
   private final InjectionFuture<ResourceManager> resourceManager;
 
   /**
@@ -46,7 +47,7 @@ public final class ReefRunnableProcessObserver implements RunnableProcessObserve
    */
   @Inject
   public ReefRunnableProcessObserver(final @Parameter(RuntimeParameters.ResourceStatusHandler.class)
-                                     EventHandler<DriverRuntimeProtocol.ResourceStatusProto> resourceStatusHandler,
+                                     EventHandler<ResourceStatusEvent> resourceStatusHandler,
                                      final InjectionFuture<ResourceManager> resourceManager) {
     this.resourceStatusHandler = resourceStatusHandler;
     this.resourceManager = resourceManager;
@@ -55,7 +56,7 @@ public final class ReefRunnableProcessObserver implements RunnableProcessObserve
   @Override
   public void onProcessStarted(final String processId) {
     this.onResourceStatus(
-        DriverRuntimeProtocol.ResourceStatusProto.newBuilder()
+        ResourceStatusEventImpl.newBuilder()
             .setIdentifier(processId)
             .setState(ReefServiceProtos.State.RUNNING)
             .build()
@@ -84,7 +85,7 @@ public final class ReefRunnableProcessObserver implements RunnableProcessObserve
    */
   private void onCleanExit(final String processId) {
     this.onResourceStatus(
-        DriverRuntimeProtocol.ResourceStatusProto.newBuilder()
+        ResourceStatusEventImpl.newBuilder()
             .setIdentifier(processId)
             .setState(ReefServiceProtos.State.DONE)
             .setExitCode(0)
@@ -100,7 +101,7 @@ public final class ReefRunnableProcessObserver implements RunnableProcessObserve
    */
   private void onUncleanExit(final String processId, final int exitCode) {
     this.onResourceStatus(
-        DriverRuntimeProtocol.ResourceStatusProto.newBuilder()
+        ResourceStatusEventImpl.newBuilder()
             .setIdentifier(processId)
             .setState(ReefServiceProtos.State.FAILED)
             .setExitCode(exitCode)
@@ -108,7 +109,7 @@ public final class ReefRunnableProcessObserver implements RunnableProcessObserve
     );
   }
 
-  private void onResourceStatus(final DriverRuntimeProtocol.ResourceStatusProto resourceStatus) {
+  private void onResourceStatus(final ResourceStatusEvent resourceStatus) {
     LOG.log(Level.INFO, "Sending resource status: {0} ", resourceStatus);
 
     // Here, we introduce an arbitrary wait. This is to make sure that at the exit of an Evaluator, the last
diff --git a/lang/java/reef-runtime-local/src/test/java/org/apache/reef/runtime/local/driver/ResourceRequestQueueTest.java b/lang/java/reef-runtime-local/src/test/java/org/apache/reef/runtime/local/driver/ResourceRequestQueueTest.java
index 658747d..8fb1872 100644
--- a/lang/java/reef-runtime-local/src/test/java/org/apache/reef/runtime/local/driver/ResourceRequestQueueTest.java
+++ b/lang/java/reef-runtime-local/src/test/java/org/apache/reef/runtime/local/driver/ResourceRequestQueueTest.java
@@ -18,7 +18,7 @@
  */
 package org.apache.reef.runtime.local.driver;
 
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEventImpl;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -58,6 +58,6 @@ public class ResourceRequestQueueTest {
   }
 
   private ResourceRequest getAlmostSatisfied() {
-    return new ResourceRequest(DriverRuntimeProtocol.ResourceRequestProto.newBuilder().setResourceCount(1).setMemorySize(128).build());
+    return new ResourceRequest(ResourceRequestEventImpl.newBuilder().setResourceCount(1).setMemorySize(128).build());
   }
 }
\ No newline at end of file
diff --git a/lang/java/reef-runtime-local/src/test/java/org/apache/reef/runtime/local/driver/ResourceRequestTest.java b/lang/java/reef-runtime-local/src/test/java/org/apache/reef/runtime/local/driver/ResourceRequestTest.java
index 3156a02..8eb310a 100644
--- a/lang/java/reef-runtime-local/src/test/java/org/apache/reef/runtime/local/driver/ResourceRequestTest.java
+++ b/lang/java/reef-runtime-local/src/test/java/org/apache/reef/runtime/local/driver/ResourceRequestTest.java
@@ -18,7 +18,7 @@
  */
 package org.apache.reef.runtime.local.driver;
 
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEventImpl;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -56,6 +56,6 @@ public final class ResourceRequestTest {
   }
 
   private ResourceRequest get(final int n) {
-    return new ResourceRequest(DriverRuntimeProtocol.ResourceRequestProto.newBuilder().setResourceCount(n).setMemorySize(128).build());
+    return new ResourceRequest(ResourceRequestEventImpl.newBuilder().setResourceCount(n).setMemorySize(128).build());
   }
 }
\ No newline at end of file
diff --git a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/client/MesosJobSubmissionHandler.java b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/client/MesosJobSubmissionHandler.java
index 29e1c21..d90c663 100644
--- a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/client/MesosJobSubmissionHandler.java
+++ b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/client/MesosJobSubmissionHandler.java
@@ -20,10 +20,10 @@ package org.apache.reef.runtime.mesos.client;
 
 import org.apache.reef.annotations.audience.ClientSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.ClientRuntimeProtocol;
-import org.apache.reef.proto.ReefServiceProtos.FileResourceProto;
+import org.apache.reef.runtime.common.client.api.JobSubmissionEvent;
 import org.apache.reef.runtime.common.client.api.JobSubmissionHandler;
 import org.apache.reef.runtime.common.files.ClasspathProvider;
+import org.apache.reef.runtime.common.files.FileResource;
 import org.apache.reef.runtime.common.files.REEFFileNames;
 import org.apache.reef.runtime.common.launch.JavaLaunchCommandBuilder;
 import org.apache.reef.runtime.common.parameters.JVMHeapSlack;
@@ -78,10 +78,10 @@ final class MesosJobSubmissionHandler implements JobSubmissionHandler {
   }
 
   @Override
-  public void onNext(final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto) {
+  public void onNext(final JobSubmissionEvent jobSubmissionEvent) {
     try {
       final File jobFolder = new File(new File(this.rootFolderName),
-          "/" + jobSubmissionProto.getIdentifier() + "-" + System.currentTimeMillis() + "/");
+          "/" + jobSubmissionEvent.getIdentifier() + "-" + System.currentTimeMillis() + "/");
 
       final File driverFolder = new File(jobFolder, DRIVER_FOLDER_NAME);
       driverFolder.mkdirs();
@@ -91,7 +91,7 @@ final class MesosJobSubmissionHandler implements JobSubmissionHandler {
 
       final File localFolder = new File(reefFolder, this.fileNames.getLocalFolderName());
       localFolder.mkdirs();
-      for (final FileResourceProto file : jobSubmissionProto.getLocalFileList()) {
+      for (final FileResource file : jobSubmissionEvent.getLocalFileList()) {
         final Path src = new File(file.getPath()).toPath();
         final Path dst = new File(driverFolder, this.fileNames.getLocalFolderPath() + "/" + file.getName()).toPath();
         Files.copy(src, dst, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
@@ -99,7 +99,7 @@ final class MesosJobSubmissionHandler implements JobSubmissionHandler {
 
       final File globalFolder = new File(reefFolder, this.fileNames.getGlobalFolderName());
       globalFolder.mkdirs();
-      for (final FileResourceProto file : jobSubmissionProto.getGlobalFileList()) {
+      for (final FileResource file : jobSubmissionEvent.getGlobalFileList()) {
         final Path src = new File(file.getPath()).toPath();
         final Path dst = new File(driverFolder, this.fileNames.getGlobalFolderPath() + "/" + file.getName()).toPath();
         Files.copy(src, dst, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
@@ -108,21 +108,21 @@ final class MesosJobSubmissionHandler implements JobSubmissionHandler {
       final Configuration driverConfiguration =
           Configurations.merge(MesosDriverConfiguration.CONF
               .set(MesosDriverConfiguration.MESOS_MASTER_IP, this.masterIp)
-              .set(MesosDriverConfiguration.JOB_IDENTIFIER, jobSubmissionProto.getIdentifier())
-              .set(MesosDriverConfiguration.CLIENT_REMOTE_IDENTIFIER, jobSubmissionProto.getRemoteId())
+              .set(MesosDriverConfiguration.JOB_IDENTIFIER, jobSubmissionEvent.getIdentifier())
+              .set(MesosDriverConfiguration.CLIENT_REMOTE_IDENTIFIER, jobSubmissionEvent.getRemoteId())
               .set(MesosDriverConfiguration.JVM_HEAP_SLACK, this.jvmSlack)
               .set(MesosDriverConfiguration.SCHEDULER_DRIVER_CAPACITY, 1) // must be 1 as there is 1 scheduler at the same time
               .build(),
-          this.configurationSerializer.fromString(jobSubmissionProto.getConfiguration()));
+          this.configurationSerializer.fromString(jobSubmissionEvent.getConfiguration()));
       final File runtimeConfigurationFile = new File(driverFolder, this.fileNames.getDriverConfigurationPath());
       this.configurationSerializer.toFile(driverConfiguration, runtimeConfigurationFile);
 
       final List<String> launchCommand = new JavaLaunchCommandBuilder()
-          .setErrorHandlerRID(jobSubmissionProto.getRemoteId())
-          .setLaunchID(jobSubmissionProto.getIdentifier())
+          .setErrorHandlerRID(jobSubmissionEvent.getRemoteId())
+          .setLaunchID(jobSubmissionEvent.getIdentifier())
           .setConfigurationFileName(this.fileNames.getDriverConfigurationPath())
           .setClassPath(this.classpath.getDriverClasspath())
-          .setMemory(jobSubmissionProto.getDriverMemory())
+          .setMemory(jobSubmissionEvent.getDriverMemory().get())
           .build();
 
       final File errFile = new File(driverFolder, fileNames.getDriverStderrFileName());
diff --git a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceLaunchHandler.java b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceLaunchHandler.java
index 7ce98f8..94f1940 100644
--- a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceLaunchHandler.java
+++ b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceLaunchHandler.java
@@ -22,7 +22,7 @@ import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
 import org.apache.reef.io.TempFileCreator;
 import org.apache.reef.io.WorkingDirectoryTempFileCreator;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceLaunchEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceLaunchHandler;
 import org.apache.reef.runtime.common.files.ClasspathProvider;
 import org.apache.reef.runtime.common.files.JobJarMaker;
@@ -78,15 +78,15 @@ final class MesosResourceLaunchHandler implements ResourceLaunchHandler {
 
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceLaunchProto resourceLaunchProto) {
+  public void onNext(final ResourceLaunchEvent resourceLaunchEvent) {
     try {
-      LOG.log(Level.INFO, "resourceLaunchProto. {0}", resourceLaunchProto.toString());
+      LOG.log(Level.INFO, "resourceLaunch. {0}", resourceLaunchEvent.toString());
 
       final File localStagingFolder =
           Files.createTempDirectory(this.fileNames.getEvaluatorFolderPrefix()).toFile();
 
       final Configuration evaluatorConfiguration = Tang.Factory.getTang()
-          .newConfigurationBuilder(this.configurationSerializer.fromString(resourceLaunchProto.getEvaluatorConf()))
+          .newConfigurationBuilder(this.configurationSerializer.fromString(resourceLaunchEvent.getEvaluatorConf()))
           .bindImplementation(TempFileCreator.class, WorkingDirectoryTempFileCreator.class)
           .build();
 
@@ -94,15 +94,15 @@ final class MesosResourceLaunchHandler implements ResourceLaunchHandler {
           localStagingFolder, this.fileNames.getEvaluatorConfigurationName());
       this.configurationSerializer.toFile(evaluatorConfiguration, configurationFile);
 
-      JobJarMaker.copy(resourceLaunchProto.getFileList(), localStagingFolder);
+      JobJarMaker.copy(resourceLaunchEvent.getFileList(), localStagingFolder);
 
       final FileSystem fileSystem = FileSystem.get(new org.apache.hadoop.conf.Configuration());
-      final Path hdfsFolder = new Path(fileSystem.getUri() + "/" + resourceLaunchProto.getIdentifier() + "/");
+      final Path hdfsFolder = new Path(fileSystem.getUri() + "/" + resourceLaunchEvent.getIdentifier() + "/");
       FileUtil.copy(localStagingFolder, fileSystem, hdfsFolder, false, new org.apache.hadoop.conf.Configuration());
 
       // TODO: Replace REEFExecutor with a simple launch command (we only need to launch REEFExecutor)
       final LaunchCommandBuilder commandBuilder;
-      switch (resourceLaunchProto.getType()) {
+      switch (resourceLaunchEvent.getType()) {
         case JVM:
           commandBuilder = new JavaLaunchCommandBuilder().setClassPath(this.classpath.getEvaluatorClasspath());
           break;
@@ -115,13 +115,13 @@ final class MesosResourceLaunchHandler implements ResourceLaunchHandler {
 
       final List<String> command = commandBuilder
           .setErrorHandlerRID(this.remoteManager.getMyIdentifier())
-          .setLaunchID(resourceLaunchProto.getIdentifier())
+          .setLaunchID(resourceLaunchEvent.getIdentifier())
           .setConfigurationFileName(this.fileNames.getEvaluatorConfigurationPath())
-          .setMemory((int) (this.jvmHeapFactor * this.executors.getMemory(resourceLaunchProto.getIdentifier())))
+          .setMemory((int) (this.jvmHeapFactor * this.executors.getMemory(resourceLaunchEvent.getIdentifier())))
           .build();
 
       this.executors.launchEvaluator(
-          new EvaluatorLaunch(resourceLaunchProto.getIdentifier(), StringUtils.join(command, ' ')));
+          new EvaluatorLaunch(resourceLaunchEvent.getIdentifier(), StringUtils.join(command, ' ')));
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
diff --git a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceReleaseHandler.java b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceReleaseHandler.java
index 41c487e..4c34aef 100644
--- a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceReleaseHandler.java
+++ b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceReleaseHandler.java
@@ -20,7 +20,7 @@ package org.apache.reef.runtime.mesos.driver;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceReleaseEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceReleaseHandler;
 
 import javax.inject.Inject;
@@ -36,7 +36,7 @@ final class MesosResourceReleaseHandler implements ResourceReleaseHandler {
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceReleaseProto resourceReleaseProto) {
-    REEFScheduler.onResourceRelease(resourceReleaseProto);
+  public void onNext(final ResourceReleaseEvent resourceReleaseEvent) {
+    REEFScheduler.onResourceRelease(resourceReleaseEvent);
   }
 }
diff --git a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceRequestHandler.java b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceRequestHandler.java
index a9c1016..feca5b8 100644
--- a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceRequestHandler.java
+++ b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/MesosResourceRequestHandler.java
@@ -20,7 +20,7 @@ package org.apache.reef.runtime.mesos.driver;
 
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceRequestHandler;
 
 import javax.inject.Inject;
@@ -36,7 +36,7 @@ final class MesosResourceRequestHandler implements ResourceRequestHandler {
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceRequestProto resourceRequestProto) {
-    REEFScheduler.onResourceRequest(resourceRequestProto);
+  public void onNext(final ResourceRequestEvent resourceRequestEvent) {
+    REEFScheduler.onResourceRequest(resourceRequestEvent);
   }
 }
\ No newline at end of file
diff --git a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/REEFEventHandlers.java b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/REEFEventHandlers.java
index fd5cce2..c8a5fa6 100644
--- a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/REEFEventHandlers.java
+++ b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/REEFEventHandlers.java
@@ -19,11 +19,11 @@
 package org.apache.reef.runtime.mesos.driver;
 
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol.NodeDescriptorProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.ResourceAllocationProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.ResourceStatusProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.RuntimeStatusProto;
 import org.apache.reef.runtime.common.driver.api.RuntimeParameters;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.RuntimeStatusEvent;
 import org.apache.reef.tang.annotations.Parameter;
 import org.apache.reef.wake.EventHandler;
 
@@ -31,35 +31,35 @@ import javax.inject.Inject;
 
 @Private
 final class REEFEventHandlers {
-  private final EventHandler<ResourceAllocationProto> resourceAllocationEventHandler;
-  private final EventHandler<RuntimeStatusProto> runtimeStatusEventHandler;
-  private final EventHandler<NodeDescriptorProto> nodeDescriptorEventHandler;
-  private final EventHandler<ResourceStatusProto> resourceStatusHandlerEventHandler;
+  private final EventHandler<ResourceAllocationEvent> resourceAllocationEventHandler;
+  private final EventHandler<RuntimeStatusEvent> runtimeStatusEventHandler;
+  private final EventHandler<NodeDescriptorEvent> nodeDescriptorEventHandler;
+  private final EventHandler<ResourceStatusEvent> resourceStatusHandlerEventHandler;
 
   @Inject
-  REEFEventHandlers(final @Parameter(RuntimeParameters.ResourceAllocationHandler.class) EventHandler<ResourceAllocationProto> resourceAllocationEventHandler,
-                    final @Parameter(RuntimeParameters.RuntimeStatusHandler.class) EventHandler<RuntimeStatusProto> runtimeStatusEventHandler,
-                    final @Parameter(RuntimeParameters.NodeDescriptorHandler.class) EventHandler<NodeDescriptorProto> nodeDescriptorEventHandler,
-                    final @Parameter(RuntimeParameters.ResourceStatusHandler.class) EventHandler<ResourceStatusProto> resourceStatusHandlerEventHandler) {
+  REEFEventHandlers(final @Parameter(RuntimeParameters.ResourceAllocationHandler.class) EventHandler<ResourceAllocationEvent> resourceAllocationEventHandler,
+                    final @Parameter(RuntimeParameters.RuntimeStatusHandler.class) EventHandler<RuntimeStatusEvent> runtimeStatusEventHandler,
+                    final @Parameter(RuntimeParameters.NodeDescriptorHandler.class) EventHandler<NodeDescriptorEvent> nodeDescriptorEventHandler,
+                    final @Parameter(RuntimeParameters.ResourceStatusHandler.class) EventHandler<ResourceStatusEvent> resourceStatusHandlerEventHandler) {
     this.resourceAllocationEventHandler = resourceAllocationEventHandler;
     this.runtimeStatusEventHandler = runtimeStatusEventHandler;
     this.nodeDescriptorEventHandler = nodeDescriptorEventHandler;
     this.resourceStatusHandlerEventHandler = resourceStatusHandlerEventHandler;
   }
 
-  void onNodeDescriptor(final NodeDescriptorProto nodeDescriptorProto) {
+  void onNodeDescriptor(final NodeDescriptorEvent nodeDescriptorProto) {
     this.nodeDescriptorEventHandler.onNext(nodeDescriptorProto);
   }
 
-  void onRuntimeStatus(final RuntimeStatusProto runtimeStatusProto) {
+  void onRuntimeStatus(final RuntimeStatusEvent runtimeStatusProto) {
     this.runtimeStatusEventHandler.onNext(runtimeStatusProto);
   }
 
-  void onResourceAllocation(final ResourceAllocationProto resourceAllocationProto) {
+  void onResourceAllocation(final ResourceAllocationEvent resourceAllocationProto) {
     this.resourceAllocationEventHandler.onNext(resourceAllocationProto);
   }
 
-  void onResourceStatus(final ResourceStatusProto resourceStatusProto) {
+  void onResourceStatus(final ResourceStatusEvent resourceStatusProto) {
     this.resourceStatusHandlerEventHandler.onNext(resourceStatusProto);
   }
 }
\ No newline at end of file
diff --git a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/REEFScheduler.java b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/REEFScheduler.java
index 9c2c6d9..a9677c1 100644
--- a/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/REEFScheduler.java
+++ b/lang/java/reef-runtime-mesos/src/main/java/org/apache/reef/runtime/mesos/driver/REEFScheduler.java
@@ -20,22 +20,23 @@ package org.apache.reef.runtime.mesos.driver;
 
 import com.google.protobuf.ByteString;
 import org.apache.mesos.MesosSchedulerDriver;
-import org.apache.reef.proto.DriverRuntimeProtocol;
-import org.apache.reef.proto.DriverRuntimeProtocol.NodeDescriptorProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.ResourceAllocationProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.ResourceReleaseProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.ResourceRequestProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.RuntimeStatusProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.RuntimeStatusProto.Builder;
 import org.apache.reef.proto.ReefServiceProtos;
 import org.apache.reef.proto.ReefServiceProtos.State;
 import org.apache.reef.runtime.common.driver.api.AbstractDriverRuntimeConfiguration;
+import org.apache.reef.runtime.common.driver.api.ResourceReleaseEvent;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEvent;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEventImpl;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEventImpl;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEventImpl;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEventImpl;
+import org.apache.reef.runtime.common.driver.resourcemanager.RuntimeStatusEventImpl;
 import org.apache.reef.runtime.common.files.ClasspathProvider;
 import org.apache.reef.runtime.common.files.REEFFileNames;
 import org.apache.reef.runtime.mesos.driver.parameters.MesosMasterIp;
 import org.apache.reef.runtime.mesos.evaluator.REEFExecutor;
 import org.apache.reef.runtime.mesos.util.EvaluatorControl;
-import org.apache.reef.runtime.mesos.util.EvaluatorLaunch;
 import org.apache.reef.runtime.mesos.util.EvaluatorRelease;
 import org.apache.reef.runtime.mesos.util.MesosRemoteManager;
 import org.apache.reef.tang.annotations.Parameter;
@@ -106,8 +107,8 @@ final class REEFScheduler implements Scheduler {
   private final Map<String, Offer> offers = new ConcurrentHashMap<>();
 
   private int outstandingRequestCounter = 0;
-  private final ConcurrentLinkedQueue<ResourceRequestProto> outstandingRequests = new ConcurrentLinkedQueue<>();
-  private final Map<String, ResourceRequestProto> executorIdToLaunchedRequests = new ConcurrentHashMap<>();
+  private final ConcurrentLinkedQueue<ResourceRequestEvent> outstandingRequests = new ConcurrentLinkedQueue<>();
+  private final Map<String, ResourceRequestEvent> executorIdToLaunchedRequests = new ConcurrentHashMap<>();
   private final REEFExecutors executors;
 
   @Inject
@@ -151,24 +152,24 @@ final class REEFScheduler implements Scheduler {
    */
   @Override
   public void resourceOffers(final SchedulerDriver driver, final List<Protos.Offer> offers) {
-    final Map<String, NodeDescriptorProto.Builder> nodeDescriptorProtos = new HashMap<>();
+    final Map<String, NodeDescriptorEventImpl.Builder> nodeDescriptorEvents = new HashMap<>();
 
     for (final Offer offer : offers) {
-      if (nodeDescriptorProtos.get(offer.getSlaveId().getValue()) == null) {
-        nodeDescriptorProtos.put(offer.getSlaveId().getValue(), NodeDescriptorProto.newBuilder()
-            .setIdentifier(offer.getSlaveId().getValue())
-            .setHostName(offer.getHostname())
-            .setPort(MESOS_SLAVE_PORT)
-            .setMemorySize(getMemory(offer)));
+      if (nodeDescriptorEvents.get(offer.getSlaveId().getValue()) == null) {
+        nodeDescriptorEvents.put(offer.getSlaveId().getValue(), NodeDescriptorEventImpl.newBuilder()
+                .setIdentifier(offer.getSlaveId().getValue())
+                .setHostName(offer.getHostname())
+                .setPort(MESOS_SLAVE_PORT)
+                .setMemorySize(getMemory(offer)));
       } else {
-        final NodeDescriptorProto.Builder builder = nodeDescriptorProtos.get(offer.getSlaveId().getValue());
-        builder.setMemorySize(builder.getMemorySize() + getMemory(offer));
+        final NodeDescriptorEventImpl.Builder builder = nodeDescriptorEvents.get(offer.getSlaveId().getValue());
+        builder.setMemorySize(builder.build().getMemorySize() + getMemory(offer));
       }
 
       this.offers.put(offer.getId().getValue(), offer);
     }
 
-    for (final NodeDescriptorProto.Builder ndpBuilder : nodeDescriptorProtos.values()) {
+    for (final NodeDescriptorEventImpl.Builder ndpBuilder : nodeDescriptorEvents.values()) {
       this.reefEventHandlers.onNodeDescriptor(ndpBuilder.build());
     }
 
@@ -190,8 +191,8 @@ final class REEFScheduler implements Scheduler {
   public void statusUpdate(final SchedulerDriver driver, final Protos.TaskStatus taskStatus) {
     LOG.log(Level.SEVERE, "Task Status Update:", taskStatus.toString());
 
-    final DriverRuntimeProtocol.ResourceStatusProto.Builder resourceStatus =
-        DriverRuntimeProtocol.ResourceStatusProto.newBuilder().setIdentifier(taskStatus.getTaskId().getValue());
+    final ResourceStatusEventImpl.Builder resourceStatus =
+        ResourceStatusEventImpl.newBuilder().setIdentifier(taskStatus.getTaskId().getValue());
 
     switch(taskStatus.getState()) {
       case TASK_STARTING:
@@ -251,8 +252,8 @@ final class REEFScheduler implements Scheduler {
                            final Protos.SlaveID slaveId,
                            final int status) {
     final String diagnostics = "Executor Lost. executorid: "+executorId.getValue()+" slaveid: "+slaveId.getValue();
-    final DriverRuntimeProtocol.ResourceStatusProto resourceStatus =
-        DriverRuntimeProtocol.ResourceStatusProto.newBuilder()
+    final ResourceStatusEvent resourceStatus =
+        ResourceStatusEventImpl.newBuilder()
             .setIdentifier(executorId.getValue())
             .setState(State.FAILED)
             .setExitCode(status)
@@ -283,39 +284,40 @@ final class REEFScheduler implements Scheduler {
     }
   }
 
-  public void onResourceRequest(final ResourceRequestProto resourceRequestProto) {
-    this.outstandingRequestCounter += resourceRequestProto.getResourceCount();
+  public void onResourceRequest(final ResourceRequestEvent resourceRequestEvent) {
+    this.outstandingRequestCounter += resourceRequestEvent.getResourceCount();
     updateRuntimeStatus();
-    doResourceRequest(resourceRequestProto);
+    doResourceRequest(resourceRequestEvent);
   }
 
-  public void onResourceRelease(final ResourceReleaseProto resourceReleaseProto) {
-    this.executors.releaseEvaluator(new EvaluatorRelease(resourceReleaseProto.getIdentifier()));
-    this.executors.remove(resourceReleaseProto.getIdentifier());
+  public void onResourceRelease(final ResourceReleaseEvent resourceReleaseEvent) {
+    this.executors.releaseEvaluator(new EvaluatorRelease(resourceReleaseEvent.getIdentifier()));
+    this.executors.remove(resourceReleaseEvent.getIdentifier());
     updateRuntimeStatus();
   }
 
   /**
    * Greedily acquire resources by launching a Mesos Task(w/ our custom MesosExecutor) on REEF Evaluator request.
    * Either called from onResourceRequest(for a new request) or resourceOffers(for an outstanding request).
-   * TODO: reflect priority and rack/node locality specified in resourceRequestProto.
+   * TODO: reflect priority and rack/node locality specified in resourceRequestEvent.
    */
-  private synchronized void doResourceRequest(final ResourceRequestProto resourceRequestProto) {
-    int tasksToLaunchCounter = resourceRequestProto.getResourceCount();
+  private synchronized void doResourceRequest(final ResourceRequestEvent resourceRequestEvent) {
+    int tasksToLaunchCounter = resourceRequestEvent.getResourceCount();
 
     for (final Offer offer : this.offers.values()) {
-      final int cpuSlots = getCpu(offer) / resourceRequestProto.getVirtualCores();
-      final int memSlots = getMemory(offer) / resourceRequestProto.getMemorySize();
+      // TODO: There needs to be a default for memory and core
+      final int cpuSlots = getCpu(offer) / resourceRequestEvent.getVirtualCores().get();
+      final int memSlots = getMemory(offer) / resourceRequestEvent.getMemorySize().get();
       final int taskNum = Math.min(Math.min(cpuSlots, memSlots), tasksToLaunchCounter);
 
-      if (taskNum > 0 && satisfySlaveConstraint(resourceRequestProto, offer)) {
+      if (taskNum > 0 && satisfySlaveConstraint(resourceRequestEvent, offer)) {
         final List<TaskInfo> tasksToLaunch = new ArrayList<>();
         tasksToLaunchCounter -= taskNum;
 
         // Launch as many MesosTasks on the same node(offer) as possible to exploit locality.
         for (int j = 0; j < taskNum; j++) {
           final String id = offer.getId().getValue() + "-" + String.valueOf(j);
-          final String executorLaunchCommand = getExecutorLaunchCommand(id, resourceRequestProto.getMemorySize());
+          final String executorLaunchCommand = getExecutorLaunchCommand(id, resourceRequestEvent.getMemorySize().get());
 
           final ExecutorInfo executorInfo = ExecutorInfo.newBuilder()
               .setExecutorId(ExecutorID.newBuilder()
@@ -334,24 +336,24 @@ final class REEFScheduler implements Scheduler {
               .setName(id)
               .setSlaveId(offer.getSlaveId())
               .addResources(Resource.newBuilder()
-                  .setName("mem")
-                  .setType(Type.SCALAR)
-                  .setScalar(Value.Scalar.newBuilder()
-                      .setValue(resourceRequestProto.getMemorySize())
+                      .setName("mem")
+                      .setType(Type.SCALAR)
+                      .setScalar(Value.Scalar.newBuilder()
+                              .setValue(resourceRequestEvent.getMemorySize().get())
+                              .build())
                       .build())
-                  .build())
               .addResources(Resource.newBuilder()
-                  .setName("cpus")
-                  .setType(Type.SCALAR)
-                  .setScalar(Value.Scalar.newBuilder()
-                      .setValue(resourceRequestProto.getVirtualCores())
+                      .setName("cpus")
+                      .setType(Type.SCALAR)
+                      .setScalar(Value.Scalar.newBuilder()
+                              .setValue(resourceRequestEvent.getVirtualCores().get())
+                              .build())
                       .build())
-                  .build())
               .setExecutor(executorInfo)
               .build();
 
           tasksToLaunch.add(taskInfo);
-          this.executorIdToLaunchedRequests.put(id, resourceRequestProto);
+          this.executorIdToLaunchedRequests.put(id, resourceRequestEvent);
         }
 
         final Filters filters = Filters.newBuilder().setRefuseSeconds(0).build();
@@ -365,24 +367,25 @@ final class REEFScheduler implements Scheduler {
     this.offers.clear();
 
     // Save leftovers that couldn't be launched
-    outstandingRequests.add(ResourceRequestProto.newBuilder()
-        .mergeFrom(resourceRequestProto)
+    outstandingRequests.add(ResourceRequestEventImpl.newBuilder()
+        .mergeFrom(resourceRequestEvent)
         .setResourceCount(tasksToLaunchCounter)
         .build());
   }
 
   private void handleNewExecutor(final Protos.TaskStatus taskStatus) {
-    final ResourceRequestProto resourceRequestProto =
+    final ResourceRequestEvent resourceRequestProto =
         this.executorIdToLaunchedRequests.remove(taskStatus.getTaskId().getValue());
 
+    // TODO: There needs to be a default for memory and core
     final EventHandler<EvaluatorControl> evaluatorControlHandler =
         this.mesosRemoteManager.getHandler(taskStatus.getMessage(), EvaluatorControl.class);
-    this.executors.add(taskStatus.getTaskId().getValue(), resourceRequestProto.getMemorySize(), evaluatorControlHandler);
+    this.executors.add(taskStatus.getTaskId().getValue(), resourceRequestProto.getMemorySize().get(), evaluatorControlHandler);
 
-    final ResourceAllocationProto alloc = DriverRuntimeProtocol.ResourceAllocationProto.newBuilder()
+    final ResourceAllocationEvent alloc = ResourceAllocationEventImpl.newBuilder()
         .setIdentifier(taskStatus.getTaskId().getValue())
         .setNodeId(taskStatus.getSlaveId().getValue())
-        .setResourceMemory(resourceRequestProto.getMemorySize())
+        .setResourceMemory(resourceRequestProto.getMemorySize().get())
         .build();
     reefEventHandlers.onResourceAllocation(alloc);
 
@@ -391,7 +394,7 @@ final class REEFScheduler implements Scheduler {
   }
 
   private synchronized void updateRuntimeStatus() {
-    final Builder builder = DriverRuntimeProtocol.RuntimeStatusProto.newBuilder()
+    final RuntimeStatusEventImpl.Builder builder = RuntimeStatusEventImpl.newBuilder()
         .setName(RUNTIME_NAME)
         .setState(State.RUNNING)
         .setOutstandingContainerRequests(this.outstandingRequestCounter);
@@ -411,7 +414,7 @@ final class REEFScheduler implements Scheduler {
       throw new RuntimeException(e);
     }
 
-    final Builder runtimeStatusBuilder = RuntimeStatusProto.newBuilder()
+    final RuntimeStatusEventImpl.Builder runtimeStatusBuilder = RuntimeStatusEventImpl.newBuilder()
         .setState(State.FAILED)
         .setName(RUNTIME_NAME);
 
@@ -425,9 +428,9 @@ final class REEFScheduler implements Scheduler {
     this.reefEventHandlers.onRuntimeStatus(runtimeStatusBuilder.build());
   }
 
-  private boolean satisfySlaveConstraint(final ResourceRequestProto resourceRequestProto, final Offer offer) {
-    return resourceRequestProto.getNodeNameCount() == 0 ||
-        resourceRequestProto.getNodeNameList().contains(offer.getSlaveId().getValue());
+  private boolean satisfySlaveConstraint(final ResourceRequestEvent resourceRequestEvent, final Offer offer) {
+    return resourceRequestEvent.getNodeNameList().size() == 0 ||
+        resourceRequestEvent.getNodeNameList().contains(offer.getSlaveId().getValue());
   }
 
   private int getMemory(final Offer offer) {
diff --git a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/client/YarnJobSubmissionHandler.java b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/client/YarnJobSubmissionHandler.java
index eb6b802..a4054d1 100644
--- a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/client/YarnJobSubmissionHandler.java
+++ b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/client/YarnJobSubmissionHandler.java
@@ -25,7 +25,7 @@ import org.apache.hadoop.yarn.exceptions.YarnException;
 import org.apache.reef.annotations.audience.ClientSide;
 import org.apache.reef.annotations.audience.Private;
 import org.apache.reef.driver.parameters.DriverJobSubmissionDirectory;
-import org.apache.reef.proto.ClientRuntimeProtocol;
+import org.apache.reef.runtime.common.client.api.JobSubmissionEvent;
 import org.apache.reef.runtime.common.client.api.JobSubmissionHandler;
 import org.apache.reef.runtime.common.files.ClasspathProvider;
 import org.apache.reef.runtime.common.files.JobJarMaker;
@@ -85,28 +85,28 @@ final class YarnJobSubmissionHandler implements JobSubmissionHandler {
   }
 
   @Override
-  public void onNext(final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto) {
+  public void onNext(final JobSubmissionEvent jobSubmissionEvent) {
 
-    LOG.log(Level.FINEST, "Submitting job with ID [{0}]", jobSubmissionProto.getIdentifier());
+    LOG.log(Level.FINEST, "Submitting job with ID [{0}]", jobSubmissionEvent.getIdentifier());
 
     try (final YarnSubmissionHelper submissionHelper =
              new YarnSubmissionHelper(this.yarnConfiguration, this.fileNames, this.classpath)) {
 
       LOG.log(Level.FINE, "Assembling submission JAR for the Driver.");
       final JobFolder jobFolderOnDfs = this.uploader.createJobFolder(submissionHelper.getApplicationId());
-      final Configuration driverConfiguration = makeDriverConfiguration(jobSubmissionProto, jobFolderOnDfs.getPath());
-      final File jobSubmissionFile = this.jobJarMaker.createJobSubmissionJAR(jobSubmissionProto, driverConfiguration);
+      final Configuration driverConfiguration = makeDriverConfiguration(jobSubmissionEvent, jobFolderOnDfs.getPath());
+      final File jobSubmissionFile = this.jobJarMaker.createJobSubmissionJAR(jobSubmissionEvent, driverConfiguration);
       final LocalResource driverJarOnDfs = jobFolderOnDfs.uploadAsLocalResource(jobSubmissionFile);
 
       submissionHelper
           .addLocalResource(this.fileNames.getREEFFolderName(), driverJarOnDfs)
-          .setApplicationName(jobSubmissionProto.getIdentifier())
-          .setDriverMemory(jobSubmissionProto.getDriverMemory())
-          .setPriority(getPriority(jobSubmissionProto))
-          .setQueue(getQueue(jobSubmissionProto, "default"))
-          .submit(jobSubmissionProto.getRemoteId());
+          .setApplicationName(jobSubmissionEvent.getIdentifier())
+          .setDriverMemory(jobSubmissionEvent.getDriverMemory().get())
+          .setPriority(getPriority(jobSubmissionEvent))
+          .setQueue(getQueue(jobSubmissionEvent, "default"))
+          .submit(jobSubmissionEvent.getRemoteId());
 
-      LOG.log(Level.FINEST, "Submitted job with ID [{0}]", jobSubmissionProto.getIdentifier());
+      LOG.log(Level.FINEST, "Submitted job with ID [{0}]", jobSubmissionEvent.getIdentifier());
     } catch (final YarnException | IOException e) {
       throw new RuntimeException("Unable to submit Driver to YARN.", e);
     }
@@ -116,9 +116,9 @@ final class YarnJobSubmissionHandler implements JobSubmissionHandler {
    * Assembles the Driver configuration.
    */
   private Configuration makeDriverConfiguration(
-      final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto,
+      final JobSubmissionEvent jobSubmissionEvent,
       final Path jobFolderPath) throws IOException {
-    final Configuration config = this.configurationSerializer.fromString(jobSubmissionProto.getConfiguration());
+    final Configuration config = this.configurationSerializer.fromString(jobSubmissionEvent.getConfiguration());
     final String userBoundJobSubmissionDirectory = config.getNamedParameter((NamedParameterNode<?>) config.getClassHierarchy().getNode(ReflectionUtilities.getFullName(DriverJobSubmissionDirectory.class)));
     LOG.log(Level.FINE, "user bound job submission Directory: " + userBoundJobSubmissionDirectory);
     final String finalJobFolderPath =
@@ -127,27 +127,24 @@ final class YarnJobSubmissionHandler implements JobSubmissionHandler {
     return Configurations.merge(
         YarnDriverConfiguration.CONF
             .set(YarnDriverConfiguration.JOB_SUBMISSION_DIRECTORY, finalJobFolderPath)
-            .set(YarnDriverConfiguration.JOB_IDENTIFIER, jobSubmissionProto.getIdentifier())
-            .set(YarnDriverConfiguration.CLIENT_REMOTE_IDENTIFIER, jobSubmissionProto.getRemoteId())
+            .set(YarnDriverConfiguration.JOB_IDENTIFIER, jobSubmissionEvent.getIdentifier())
+            .set(YarnDriverConfiguration.CLIENT_REMOTE_IDENTIFIER, jobSubmissionEvent.getRemoteId())
             .set(YarnDriverConfiguration.JVM_HEAP_SLACK, this.jvmSlack)
             .build(),
-        this.configurationSerializer.fromString(jobSubmissionProto.getConfiguration()));
+        this.configurationSerializer.fromString(jobSubmissionEvent.getConfiguration()));
   }
 
-  private static int getPriority(final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto) {
-    return jobSubmissionProto.hasPriority() ? jobSubmissionProto.getPriority() : 0;
+  private static int getPriority(final JobSubmissionEvent jobSubmissionEvent) {
+    return jobSubmissionEvent.getPriority().orElse(0);
   }
 
   /**
-   * Extract the queue name from the jobSubmissionProto or return default if none is set.
+   * Extract the queue name from the jobSubmissionEvent or return default if none is set.
    * <p/>
    * TODO: Revisit this. We also have a named parameter for the queue in YarnClientConfiguration.
    */
-  private final String getQueue(final ClientRuntimeProtocol.JobSubmissionProto jobSubmissionProto,
+  private final String getQueue(final JobSubmissionEvent jobSubmissionEvent,
                                 final String defaultQueue) {
-    return jobSubmissionProto.hasQueue() && !jobSubmissionProto.getQueue().isEmpty() ?
-        jobSubmissionProto.getQueue() : defaultQueue;
+    return jobSubmissionEvent.getQueue().orElse(defaultQueue);
   }
-
-
 }
diff --git a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/EvaluatorSetupHelper.java b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/EvaluatorSetupHelper.java
index 3a2ff5c..70b9f3a 100644
--- a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/EvaluatorSetupHelper.java
+++ b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/EvaluatorSetupHelper.java
@@ -23,7 +23,7 @@ import org.apache.hadoop.yarn.api.records.LocalResource;
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.io.TempFileCreator;
 import org.apache.reef.io.WorkingDirectoryTempFileCreator;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceLaunchEvent;
 import org.apache.reef.runtime.common.files.JobJarMaker;
 import org.apache.reef.runtime.common.files.REEFFileNames;
 import org.apache.reef.runtime.common.parameters.DeleteTempFiles;
@@ -88,12 +88,12 @@ final class EvaluatorSetupHelper {
   /**
    * Sets up the LocalResources for a new Evaluator.
    *
-   * @param resourceLaunchProto
+   * @param resourceLaunchEvent
    * @return
    * @throws IOException
    */
   Map<String, LocalResource> getResources(
-      final DriverRuntimeProtocol.ResourceLaunchProto resourceLaunchProto)
+      final ResourceLaunchEvent resourceLaunchEvent)
       throws IOException {
 
     final Map<String, LocalResource> result = new HashMap<>();
@@ -103,10 +103,10 @@ final class EvaluatorSetupHelper {
 
     // Write the configuration
     final File configurationFile = new File(localStagingFolder, this.fileNames.getEvaluatorConfigurationName());
-    this.configurationSerializer.toFile(makeEvaluatorConfiguration(resourceLaunchProto), configurationFile);
+    this.configurationSerializer.toFile(makeEvaluatorConfiguration(resourceLaunchEvent), configurationFile);
 
     // Copy files to the staging folder
-    JobJarMaker.copy(resourceLaunchProto.getFileList(), localStagingFolder);
+    JobJarMaker.copy(resourceLaunchEvent.getFileList(), localStagingFolder);
 
     // Make a JAR file out of it
     final File localFile = tempFileCreator.createTempFile(
@@ -132,15 +132,15 @@ final class EvaluatorSetupHelper {
   /**
    * Assembles the configuration for an Evaluator.
    *
-   * @param resourceLaunchProto
+   * @param resourceLaunchEvent
    * @return
    * @throws IOException
    */
 
-  private Configuration makeEvaluatorConfiguration(final DriverRuntimeProtocol.ResourceLaunchProto resourceLaunchProto)
+  private Configuration makeEvaluatorConfiguration(final ResourceLaunchEvent resourceLaunchEvent)
       throws IOException {
     return Tang.Factory.getTang()
-        .newConfigurationBuilder(this.configurationSerializer.fromString(resourceLaunchProto.getEvaluatorConf()))
+        .newConfigurationBuilder(this.configurationSerializer.fromString(resourceLaunchEvent.getEvaluatorConf()))
         .bindImplementation(TempFileCreator.class, WorkingDirectoryTempFileCreator.class)
         .build();
   }
diff --git a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/REEFEventHandlers.java b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/REEFEventHandlers.java
index ec43666..94755bb 100644
--- a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/REEFEventHandlers.java
+++ b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/REEFEventHandlers.java
@@ -19,8 +19,11 @@
 package org.apache.reef.runtime.yarn.driver;
 
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
 import org.apache.reef.runtime.common.driver.api.RuntimeParameters;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEvent;
+import org.apache.reef.runtime.common.driver.resourcemanager.RuntimeStatusEvent;
 import org.apache.reef.tang.annotations.Parameter;
 import org.apache.reef.wake.EventHandler;
 
@@ -32,16 +35,16 @@ import javax.inject.Inject;
 // This is a great place to add a thread boundary, should that need arise.
 @Private
 final class REEFEventHandlers implements AutoCloseable {
-  private final EventHandler<DriverRuntimeProtocol.ResourceAllocationProto> resourceAllocationHandler;
-  private final EventHandler<DriverRuntimeProtocol.ResourceStatusProto> resourceStatusHandler;
-  private final EventHandler<DriverRuntimeProtocol.RuntimeStatusProto> runtimeStatusHandler;
-  private final EventHandler<DriverRuntimeProtocol.NodeDescriptorProto> nodeDescriptorProtoEventHandler;
+  private final EventHandler<ResourceAllocationEvent> resourceAllocationHandler;
+  private final EventHandler<ResourceStatusEvent> resourceStatusHandler;
+  private final EventHandler<RuntimeStatusEvent> runtimeStatusHandler;
+  private final EventHandler<NodeDescriptorEvent> nodeDescriptorProtoEventHandler;
 
   @Inject
-  REEFEventHandlers(final @Parameter(RuntimeParameters.NodeDescriptorHandler.class) EventHandler<DriverRuntimeProtocol.NodeDescriptorProto> nodeDescriptorProtoEventHandler,
-                    final @Parameter(RuntimeParameters.RuntimeStatusHandler.class) EventHandler<DriverRuntimeProtocol.RuntimeStatusProto> runtimeStatusProtoEventHandler,
-                    final @Parameter(RuntimeParameters.ResourceAllocationHandler.class) EventHandler<DriverRuntimeProtocol.ResourceAllocationProto> resourceAllocationHandler,
-                    final @Parameter(RuntimeParameters.ResourceStatusHandler.class) EventHandler<DriverRuntimeProtocol.ResourceStatusProto> resourceStatusHandler) {
+  REEFEventHandlers(final @Parameter(RuntimeParameters.NodeDescriptorHandler.class) EventHandler<NodeDescriptorEvent> nodeDescriptorProtoEventHandler,
+                    final @Parameter(RuntimeParameters.RuntimeStatusHandler.class) EventHandler<RuntimeStatusEvent> runtimeStatusProtoEventHandler,
+                    final @Parameter(RuntimeParameters.ResourceAllocationHandler.class) EventHandler<ResourceAllocationEvent> resourceAllocationHandler,
+                    final @Parameter(RuntimeParameters.ResourceStatusHandler.class) EventHandler<ResourceStatusEvent> resourceStatusHandler) {
     this.resourceAllocationHandler = resourceAllocationHandler;
     this.resourceStatusHandler = resourceStatusHandler;
     this.runtimeStatusHandler = runtimeStatusProtoEventHandler;
@@ -53,35 +56,35 @@ final class REEFEventHandlers implements AutoCloseable {
    *
    * @param nodeDescriptorProto
    */
-  void onNodeDescriptor(final DriverRuntimeProtocol.NodeDescriptorProto nodeDescriptorProto) {
+  void onNodeDescriptor(final NodeDescriptorEvent nodeDescriptorProto) {
     this.nodeDescriptorProtoEventHandler.onNext(nodeDescriptorProto);
   }
 
   /**
    * Update REEF's view on the runtime status.
    *
-   * @param runtimeStatusProto
+   * @param runtimeStatusEvent
    */
-  void onRuntimeStatus(final DriverRuntimeProtocol.RuntimeStatusProto runtimeStatusProto) {
-    this.runtimeStatusHandler.onNext(runtimeStatusProto);
+  void onRuntimeStatus(final RuntimeStatusEvent runtimeStatusEvent) {
+    this.runtimeStatusHandler.onNext(runtimeStatusEvent);
   }
 
   /**
    * Inform REEF of a fresh resource allocation.
    *
-   * @param resourceAllocationProto
+   * @param resourceAllocationEvent
    */
-  void onResourceAllocation(final DriverRuntimeProtocol.ResourceAllocationProto resourceAllocationProto) {
-    this.resourceAllocationHandler.onNext(resourceAllocationProto);
+  void onResourceAllocation(final ResourceAllocationEvent resourceAllocationEvent) {
+    this.resourceAllocationHandler.onNext(resourceAllocationEvent);
   }
 
   /**
    * Update REEF on a change to the status of a resource.
    *
-   * @param resourceStatusProto
+   * @param resourceStatusEvent
    */
-  void onResourceStatus(final DriverRuntimeProtocol.ResourceStatusProto resourceStatusProto) {
-    this.resourceStatusHandler.onNext(resourceStatusProto);
+  void onResourceStatus(final ResourceStatusEvent resourceStatusEvent) {
+    this.resourceStatusHandler.onNext(resourceStatusEvent);
   }
 
   @Override
diff --git a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YARNResourceLaunchHandler.java b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YARNResourceLaunchHandler.java
index 073cf8c..8401e67 100644
--- a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YARNResourceLaunchHandler.java
+++ b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YARNResourceLaunchHandler.java
@@ -23,7 +23,7 @@ import org.apache.hadoop.yarn.api.ApplicationConstants;
 import org.apache.hadoop.yarn.api.records.Container;
 import org.apache.hadoop.yarn.api.records.ContainerLaunchContext;
 import org.apache.hadoop.yarn.api.records.LocalResource;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceLaunchEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceLaunchHandler;
 import org.apache.reef.runtime.common.files.ClasspathProvider;
 import org.apache.reef.runtime.common.files.REEFFileNames;
@@ -73,18 +73,18 @@ public final class YARNResourceLaunchHandler implements ResourceLaunchHandler {
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceLaunchProto resourceLaunchProto) {
+  public void onNext(final ResourceLaunchEvent resourceLaunchEvent) {
     try {
 
-      final String containerId = resourceLaunchProto.getIdentifier();
-      LOG.log(Level.FINEST, "TIME: Start ResourceLaunchProto {0}", containerId);
+      final String containerId = resourceLaunchEvent.getIdentifier();
+      LOG.log(Level.FINEST, "TIME: Start ResourceLaunch {0}", containerId);
       final Container container = this.containers.get(containerId);
       LOG.log(Level.FINEST, "Setting up container launch container for id={0}", container.getId());
       final Map<String, LocalResource> localResources =
-          this.evaluatorSetupHelper.getResources(resourceLaunchProto);
+          this.evaluatorSetupHelper.getResources(resourceLaunchEvent);
 
       final LaunchCommandBuilder commandBuilder;
-      switch (resourceLaunchProto.getType()) {
+      switch (resourceLaunchEvent.getType()) {
         case JVM:
           commandBuilder = new JavaLaunchCommandBuilder()
               .setClassPath(this.classpath.getEvaluatorClasspath());
@@ -94,12 +94,12 @@ public final class YARNResourceLaunchHandler implements ResourceLaunchHandler {
           break;
         default:
           throw new IllegalArgumentException(
-              "Unsupported container type: " + resourceLaunchProto.getType());
+              "Unsupported container type: " + resourceLaunchEvent.getType());
       }
 
       final List<String> command = commandBuilder
-          .setErrorHandlerRID(resourceLaunchProto.getRemoteId())
-          .setLaunchID(resourceLaunchProto.getIdentifier())
+          .setErrorHandlerRID(resourceLaunchEvent.getRemoteId())
+          .setLaunchID(resourceLaunchEvent.getIdentifier())
           .setConfigurationFileName(this.filenames.getEvaluatorConfigurationPath())
           .setMemory((int) (this.jvmHeapFactor * container.getResource().getMemory()))
           .setStandardErr(ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/" + this.filenames.getEvaluatorStderrFileName())
@@ -115,10 +115,10 @@ public final class YARNResourceLaunchHandler implements ResourceLaunchHandler {
       final ContainerLaunchContext ctx = YarnTypes.getContainerLaunchContext(command, localResources);
       this.yarnContainerManager.get().submit(container, ctx);
 
-      LOG.log(Level.FINEST, "TIME: End ResourceLaunchProto {0}", containerId);
+      LOG.log(Level.FINEST, "TIME: End ResourceLaunch {0}", containerId);
 
     } catch (final Throwable e) {
-      LOG.log(Level.WARNING, "Error handling resource launch message: " + resourceLaunchProto, e);
+      LOG.log(Level.WARNING, "Error handling resource launch message: " + resourceLaunchEvent, e);
       throw new RuntimeException(e);
     }
   }
diff --git a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YARNResourceReleaseHandler.java b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YARNResourceReleaseHandler.java
index dda9fb3..9ce3c69 100644
--- a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YARNResourceReleaseHandler.java
+++ b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YARNResourceReleaseHandler.java
@@ -18,7 +18,7 @@
  */
 package org.apache.reef.runtime.yarn.driver;
 
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceReleaseEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceReleaseHandler;
 import org.apache.reef.tang.InjectionFuture;
 
@@ -42,8 +42,8 @@ public final class YARNResourceReleaseHandler implements ResourceReleaseHandler
   }
 
   @Override
-  public void onNext(final DriverRuntimeProtocol.ResourceReleaseProto resourceReleaseProto) {
-    final String containerId = resourceReleaseProto.getIdentifier();
+  public void onNext(final ResourceReleaseEvent resourceReleaseEvent) {
+    final String containerId = resourceReleaseEvent.getIdentifier();
     LOG.log(Level.FINEST, "Releasing container {0}", containerId);
     this.yarnContainerManager.get().release(containerId);
   }
diff --git a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YarnContainerManager.java b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YarnContainerManager.java
index bd8128b..37fc784 100644
--- a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YarnContainerManager.java
+++ b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YarnContainerManager.java
@@ -33,14 +33,13 @@ import org.apache.hadoop.yarn.client.api.async.NMClientAsync;
 import org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl;
 import org.apache.hadoop.yarn.conf.YarnConfiguration;
 import org.apache.hadoop.yarn.exceptions.YarnException;
-import org.apache.reef.proto.DriverRuntimeProtocol;
-import org.apache.reef.proto.DriverRuntimeProtocol.NodeDescriptorProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.ResourceAllocationProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.ResourceStatusProto;
-import org.apache.reef.proto.DriverRuntimeProtocol.RuntimeStatusProto;
 import org.apache.reef.proto.ReefServiceProtos;
 import org.apache.reef.runtime.common.driver.DriverStatusManager;
 import org.apache.reef.runtime.common.driver.evaluator.EvaluatorManager;
+import org.apache.reef.runtime.common.driver.resourcemanager.NodeDescriptorEventImpl;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceAllocationEventImpl;
+import org.apache.reef.runtime.common.driver.resourcemanager.ResourceStatusEventImpl;
+import org.apache.reef.runtime.common.driver.resourcemanager.RuntimeStatusEventImpl;
 import org.apache.reef.runtime.yarn.driver.parameters.YarnHeartbeatPeriod;
 import org.apache.reef.runtime.yarn.util.YarnTypes;
 import org.apache.reef.tang.annotations.Parameter;
@@ -140,7 +139,7 @@ final class YarnContainerManager
 
   @Override
   public void onShutdownRequest() {
-    this.reefEventHandlers.onRuntimeStatus(RuntimeStatusProto.newBuilder()
+    this.reefEventHandlers.onRuntimeStatus(RuntimeStatusEventImpl.newBuilder()
         .setName(RUNTIME_NAME).setState(ReefServiceProtos.State.DONE).build());
     this.driverStatusManager.onError(new Exception("Shutdown requested by YARN."));
   }
@@ -182,8 +181,8 @@ final class YarnContainerManager
   public final void onContainerStopped(final ContainerId containerId) {
     final boolean hasContainer = this.containers.hasContainer(containerId.toString());
     if (hasContainer) {
-      final ResourceStatusProto.Builder resourceStatusBuilder =
-          ResourceStatusProto.newBuilder().setIdentifier(containerId.toString());
+      final ResourceStatusEventImpl.Builder resourceStatusBuilder =
+          ResourceStatusEventImpl.newBuilder().setIdentifier(containerId.toString());
       resourceStatusBuilder.setState(ReefServiceProtos.State.DONE);
       this.reefEventHandlers.onResourceStatus(resourceStatusBuilder.build());
     }
@@ -292,7 +291,7 @@ final class YarnContainerManager
 
   private void onNodeReport(final NodeReport nodeReport) {
     LOG.log(Level.FINE, "Send node descriptor: {0}", nodeReport);
-    this.reefEventHandlers.onNodeDescriptor(NodeDescriptorProto.newBuilder()
+    this.reefEventHandlers.onNodeDescriptor(NodeDescriptorEventImpl.newBuilder()
         .setIdentifier(nodeReport.getNodeId().toString())
         .setHostName(nodeReport.getNodeId().getHost())
         .setPort(nodeReport.getNodeId().getPort())
@@ -303,8 +302,8 @@ final class YarnContainerManager
 
   private void handleContainerError(final ContainerId containerId, final Throwable throwable) {
 
-    final ResourceStatusProto.Builder resourceStatusBuilder =
-        ResourceStatusProto.newBuilder().setIdentifier(containerId.toString());
+    final ResourceStatusEventImpl.Builder resourceStatusBuilder =
+        ResourceStatusEventImpl.newBuilder().setIdentifier(containerId.toString());
 
     resourceStatusBuilder.setState(ReefServiceProtos.State.FAILED);
     resourceStatusBuilder.setExitCode(1);
@@ -364,8 +363,8 @@ final class YarnContainerManager
     if (hasContainer) {
       LOG.log(Level.FINE, "Received container status: {0}", containerId);
 
-      final ResourceStatusProto.Builder status =
-          ResourceStatusProto.newBuilder().setIdentifier(containerId);
+      final ResourceStatusEventImpl.Builder status =
+          ResourceStatusEventImpl.newBuilder().setIdentifier(containerId);
 
       switch (value.getState()) {
         case COMPLETE:
@@ -445,7 +444,7 @@ final class YarnContainerManager
           doHomogeneousRequests();
 
           LOG.log(Level.FINEST, "Allocated Container: memory = {0}, core number = {1}", new Object[]{container.getResource().getMemory(), container.getResource().getVirtualCores()});
-          this.reefEventHandlers.onResourceAllocation(ResourceAllocationProto.newBuilder()
+          this.reefEventHandlers.onResourceAllocation(ResourceAllocationEventImpl.newBuilder()
               .setIdentifier(container.getId().toString())
               .setNodeId(container.getNodeId().toString())
               .setResourceMemory(container.getResource().getMemory())
@@ -507,8 +506,8 @@ final class YarnContainerManager
    */
   private void updateRuntimeStatus() {
 
-    final DriverRuntimeProtocol.RuntimeStatusProto.Builder builder =
-        DriverRuntimeProtocol.RuntimeStatusProto.newBuilder()
+    final RuntimeStatusEventImpl.Builder builder =
+        RuntimeStatusEventImpl.newBuilder()
             .setName(RUNTIME_NAME)
             .setState(ReefServiceProtos.State.RUNNING)
             .setOutstandingContainerRequests(this.containerRequestCounter.get());
@@ -533,7 +532,7 @@ final class YarnContainerManager
       this.resourceManager.stop();
     }
 
-    final RuntimeStatusProto.Builder runtimeStatusBuilder = RuntimeStatusProto.newBuilder()
+    final RuntimeStatusEventImpl.Builder runtimeStatusBuilder = RuntimeStatusEventImpl.newBuilder()
         .setState(ReefServiceProtos.State.FAILED)
         .setName(RUNTIME_NAME);
 
@@ -590,7 +589,7 @@ final class YarnContainerManager
     LOG.log(Level.WARNING, "Container [" + containerId +
         "] has failed during driver restart process, FailedEvaluaorHandler will be triggered, but no additional evaluator can be requested due to YARN-2433.");
     // trigger a failed evaluator event
-    this.reefEventHandlers.onResourceStatus(ResourceStatusProto.newBuilder()
+    this.reefEventHandlers.onResourceStatus(ResourceStatusEventImpl.newBuilder()
         .setIdentifier(containerId)
         .setState(ReefServiceProtos.State.FAILED)
         .setExitCode(1)
diff --git a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YarnResourceRequestHandler.java b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YarnResourceRequestHandler.java
index 6762362..9b8fcc0 100644
--- a/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YarnResourceRequestHandler.java
+++ b/lang/java/reef-runtime-yarn/src/main/java/org/apache/reef/runtime/yarn/driver/YarnResourceRequestHandler.java
@@ -24,7 +24,7 @@ import org.apache.hadoop.yarn.client.api.AMRMClient;
 import org.apache.hadoop.yarn.util.Records;
 import org.apache.reef.annotations.audience.DriverSide;
 import org.apache.reef.annotations.audience.Private;
-import org.apache.reef.proto.DriverRuntimeProtocol;
+import org.apache.reef.runtime.common.driver.api.ResourceRequestEvent;
 import org.apache.reef.runtime.common.driver.api.ResourceRequestHandler;
 
 import javax.inject.Inject;
@@ -51,41 +51,41 @@ public final class YarnResourceRequestHandler implements ResourceRequestHandler
   }
 
   @Override
-  public synchronized void onNext(final DriverRuntimeProtocol.ResourceRequestProto resourceRequestProto) {
-    LOG.log(Level.FINEST, "Got ResourceRequestProto in YarnResourceRequestHandler: memory = {0}, cores = {1}.", new Object[]{resourceRequestProto.getMemorySize(), resourceRequestProto.getVirtualCores()});
+  public synchronized void onNext(final ResourceRequestEvent resourceRequestEvent) {
+    LOG.log(Level.FINEST, "Got ResourceRequestEvent in YarnResourceRequestHandler: memory = {0}, cores = {1}.", new Object[]{resourceRequestEvent.getMemorySize(), resourceRequestEvent.getVirtualCores()});
 
-    final String[] nodes = resourceRequestProto.getNodeNameCount() == 0 ? null :
-        resourceRequestProto.getNodeNameList().toArray(new String[resourceRequestProto.getNodeNameCount()]);
-    final String[] racks = resourceRequestProto.getRackNameCount() == 0 ? null :
-        resourceRequestProto.getRackNameList().toArray(new String[resourceRequestProto.getRackNameCount()]);
+    final String[] nodes = resourceRequestEvent.getNodeNameList().size() == 0 ? null :
+        resourceRequestEvent.getNodeNameList().toArray(new String[resourceRequestEvent.getNodeNameList().size()]);
+    final String[] racks = resourceRequestEvent.getRackNameList().size() == 0 ? null :
+        resourceRequestEvent.getRackNameList().toArray(new String[resourceRequestEvent.getRackNameList().size()]);
 
     // set the priority for the request
-    final Priority pri = getPriority(resourceRequestProto);
-    final Resource resource = getResource(resourceRequestProto);
-    final boolean relax_locality = !resourceRequestProto.hasRelaxLocality() || resourceRequestProto.getRelaxLocality();
+    final Priority pri = getPriority(resourceRequestEvent);
+    final Resource resource = getResource(resourceRequestEvent);
+    final boolean relax_locality = resourceRequestEvent.getRelaxLocality().orElse(true);
 
     final AMRMClient.ContainerRequest[] containerRequests =
-        new AMRMClient.ContainerRequest[resourceRequestProto.getResourceCount()];
+        new AMRMClient.ContainerRequest[resourceRequestEvent.getResourceCount()];
 
-    for (int i = 0; i < resourceRequestProto.getResourceCount(); i++) {
+    for (int i = 0; i < resourceRequestEvent.getResourceCount(); i++) {
       containerRequests[i] = new AMRMClient.ContainerRequest(resource, nodes, racks, pri, relax_locality);
     }
     this.yarnContainerRequestHandler.onContainerRequest(containerRequests);
   }
 
-  private synchronized Resource getResource(final DriverRuntimeProtocol.ResourceRequestProto resourceRequestProto) {
+  private synchronized Resource getResource(final ResourceRequestEvent resourceRequestEvent) {
     final Resource result = Records.newRecord(Resource.class);
-    final int memory = getMemory(resourceRequestProto.getMemorySize());
-    final int core = resourceRequestProto.getVirtualCores();
+    final int memory = getMemory(resourceRequestEvent.getMemorySize().get());
+    final int core = resourceRequestEvent.getVirtualCores().get();
     LOG.log(Level.FINEST, "Resource requested: memory = {0}, virtual core count = {1}.", new Object[]{memory, core});
     result.setMemory(memory);
     result.setVirtualCores(core);
     return result;
   }
 
-  private synchronized Priority getPriority(final DriverRuntimeProtocol.ResourceRequestProto resourceRequestProto) {
+  private synchronized Priority getPriority(final ResourceRequestEvent resourceRequestEvent) {
     final Priority pri = Records.newRecord(Priority.class);
-    pri.setPriority(resourceRequestProto.hasPriority() ? resourceRequestProto.getPriority() : 1);
+    pri.setPriority(resourceRequestEvent.getPriority().orElse(1));
     return pri;
   }
 
